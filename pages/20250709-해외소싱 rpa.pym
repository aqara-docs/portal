import streamlit as st
import os
import pandas as pd
import mysql.connector
from datetime import datetime, timedelta
import time
import re
import json
import requests
from dotenv import load_dotenv
import concurrent.futures
import threading
import asyncio

# 환경 변수 로드
load_dotenv()

# 환경 변수 강제 재로드 (디버깅용)
from pathlib import Path
env_path = Path('.') / '.env'
if env_path.exists():
    load_dotenv(env_path, override=True)

# API 키 정리 함수
def clean_api_key(api_key):
    """API 키에서 따옴표와 공백 제거"""
    if not api_key:
        return None
    
    # 따옴표 제거
    api_key = api_key.strip().strip("'").strip('"')
    
    # 공백 제거
    api_key = api_key.strip()
    
    return api_key if api_key else None

def get_perplexity_models(api_key):
    """Perplexity API에서 사용 가능한 모델 목록 가져오기"""
    try:
        # Perplexity API의 실제 모델 목록 (2024년 기준)
        # https://docs.perplexity.ai/guides/model-cards
        current_models = [
            "sonar-pro",
            "sonar-medium-online",
            "sonar-small-online",
            "llama-3.1-sonar-small-128k-online",
            "llama-3.1-sonar-medium-128k-online", 
            "llama-3.1-sonar-large-128k-online",
            "llama-3.1-sonar-small-128k",
            "llama-3.1-sonar-medium-128k",
            "llama-3.1-sonar-large-128k"
        ]
        
        return current_models
            
    except Exception as e:
        return []
    
    return []

# 페이지 설정
st.set_page_config(
    page_title="🔍 AI 제품 소싱 시스템",
    page_icon="🔍",
    layout="wide",
    initial_sidebar_state="expanded"
)

# CSS 스타일링
st.markdown("""
<style>
.main-header {
    background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
    padding: 1rem;
    border-radius: 10px;
    text-align: center;
    color: white;
    margin-bottom: 2rem;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.metric-container {
    background: white;
    padding: 1rem;
    border-radius: 8px;
    border-left: 4px solid #667eea;
    margin: 0.5rem 0;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.agent-card {
    background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
    padding: 1rem;
    border-radius: 10px;
    margin: 0.5rem 0;
    border: 1px solid #e1e5e9;
}

.supplier-card {
    background: white;
    border: 1px solid #e1e5e9;
    border-radius: 8px;
    padding: 1rem;
    margin: 0.5rem 0;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.search-result {
    background: #f8f9fa;
    border-left: 4px solid #28a745;
    padding: 1rem;
    margin: 0.5rem 0;
    border-radius: 4px;
}
</style>
""", unsafe_allow_html=True)

# 메인 헤더
st.markdown("""
<div class="main-header">
    <h1>🔍 AI 제품 소싱 시스템</h1>
    <p>실시간 웹 검색 기반 제조사 및 공급업체 발굴 시스템</p>
    💡 Perplexity API를 활용한 정확한 제품 소싱 및 공급업체 검증
</div>
""", unsafe_allow_html=True) 

# 인증 기능 (간단한 비밀번호 보호)
if 'authenticated' not in st.session_state:
    st.session_state.authenticated = False

admin_pw = os.getenv('ADMIN_PASSWORD')
if not admin_pw:
    st.error('환경변수(ADMIN_PASSWORD)가 설정되어 있지 않습니다. .env 파일을 확인하세요.')
    st.stop()

if not st.session_state.authenticated:
    password = st.text_input("관리자 비밀번호를 입력하세요", type="password")
    if password == admin_pw:
        st.session_state.authenticated = True
        st.rerun()
    else:
        if password:  # 비밀번호가 입력된 경우에만 오류 메시지 표시
            st.error("관리자 권한이 필요합니다")
        st.stop()

# ===== 개선된 소싱 함수들 =====

def generate_smart_search_queries(product_description, target_count=5):
    """제품 설명을 바탕으로 스마트 검색 쿼리 생성"""
    queries = []
    
    # 기본 검색 패턴들
    search_patterns = [
        f'"{product_description}" manufacturer supplier',
        f'"{product_description}" factory production',
        f'"{product_description}" OEM ODM manufacturer',
        f'"{product_description}" wholesale supplier',
        f'"{product_description}" manufacturer directory',
        f'"{product_description}" manufacturing company',
        f'"{product_description}" supplier list',
        f'"{product_description}" factory China',
        f'"{product_description}" manufacturer Vietnam',
        f'"{product_description}" supplier Korea'
    ]
    
    # 제품 키워드 추출
    keywords = extract_product_keywords(product_description)
    
    # 키워드 기반 추가 쿼리
    for keyword in keywords[:3]:  # 상위 3개 키워드만 사용
        queries.extend([
            f'"{keyword}" manufacturer supplier',
            f'"{keyword}" factory production',
            f'"{keyword}" OEM manufacturer'
        ])
    
    # 기본 패턴과 키워드 쿼리 결합
    all_queries = search_patterns + queries
    
    # 중복 제거 및 순서 섞기
    unique_queries = list(dict.fromkeys(all_queries))
    
    return unique_queries[:target_count]

def extract_product_keywords(description):
    """제품 설명에서 핵심 키워드 추출"""
    # 불용어 제거
    stop_words = {'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could', 'should', 'may', 'might', 'must', 'can', 'this', 'that', 'these', 'those', 'i', 'you', 'he', 'she', 'it', 'we', 'they', 'me', 'him', 'her', 'us', 'them', 'my', 'your', 'his', 'her', 'its', 'our', 'their', 'mine', 'yours', 'his', 'hers', 'ours', 'theirs'}
    
    # 텍스트 정리
    text = re.sub(r'[^\w\s]', ' ', description.lower())
    words = text.split()
    
    # 불용어 제거 및 길이 필터링
    keywords = [word for word in words if word not in stop_words and len(word) > 2]
    
    # 빈도 기반 정렬 (간단한 구현)
    word_freq = {}
    for word in keywords:
        word_freq[word] = word_freq.get(word, 0) + 1
    
    # 빈도순 정렬
    sorted_keywords = sorted(word_freq.items(), key=lambda x: x[1], reverse=True)
    
    return [word for word, freq in sorted_keywords[:5]]  # 상위 5개 키워드

def verify_perplexity_api_key(api_key):
    """Perplexity API 키 검증 (개선된 버전)"""
    try:
        # API 키 형식 검증
        if not api_key or not api_key.strip():
            return False, "API 키가 비어있습니다."
        
        api_key = api_key.strip()
        
        # pplx- 접두사 확인
        if not api_key.startswith('pplx-'):
            return False, f"API 키가 'pplx-'로 시작하지 않습니다. 현재: {api_key[:10]}..."
        
        # 키 길이 확인 (pplx- + 최소 20자)
        if len(api_key) < 25:
            return False, f"API 키가 너무 짧습니다. 길이: {len(api_key)}"
        
        try:
            from openai import OpenAI
            
            # Perplexity API 클라이언트 생성
            client = OpenAI(
                api_key=api_key,
                base_url="https://api.perplexity.ai"
            )
            
            # 테스트 메시지
            messages = [
                {
                    "role": "system",
                    "content": "You are a helpful assistant."
                },
                {
                    "role": "user", 
                    "content": "Hello"
                }
            ]
            
            # 여러 모델로 테스트
            test_models = ["sonar-pro", "sonar-medium-online", "sonar-small-online"]
            
            for test_model in test_models:
                try:
                    response = client.chat.completions.create(
                        model=test_model,
                        messages=messages,
                        max_tokens=10,
                        temperature=0.1
                    )
                    
                    return True, f"API 키가 유효합니다. (작동 모델: {test_model})"
                    
                except Exception as e:
                    error_msg = str(e)
                    
                    if "Invalid model" in error_msg or "model not found" in error_msg.lower():
                        continue  # 다음 모델 시도
                    elif "authentication" in error_msg.lower() or "unauthorized" in error_msg.lower():
                        return False, "API 키가 유효하지 않습니다. (인증 실패)"
                    elif "rate limit" in error_msg.lower() or "quota" in error_msg.lower():
                        return False, "API 요청 한도를 초과했습니다."
                    else:
                        continue  # 다른 오류는 다음 모델 시도
            
            # 모든 모델에서 실패한 경우
            return False, "모든 테스트 모델에서 실패했습니다. API 키를 확인해주세요."
            
        except ImportError:
            return False, "OpenAI 라이브러리가 설치되지 않았습니다. 'pip install openai'를 실행하세요."
        except Exception as e:
            return False, f"OpenAI 클라이언트 초기화 오류: {str(e)}"
            
    except requests.exceptions.Timeout:
        return False, "API 요청 시간 초과"
    except requests.exceptions.ConnectionError:
        return False, "네트워크 연결 오류"
    except Exception as e:
        return False, f"API 키 검증 중 예상치 못한 오류: {str(e)}"

def search_manufacturers_with_perplexity(product_description, max_results=15):
    """Perplexity API를 사용한 제조사 검색 (개선된 버전)"""
    try:
        raw_api_key = os.environ.get('PERPLEXITY_API_KEY')
        api_key = clean_api_key(raw_api_key)
        
        if not api_key:
            st.error("❌ PERPLEXITY_API_KEY가 설정되지 않았습니다.")
            if raw_api_key:
                st.caption(f"원본 키: '{raw_api_key[:30]}...' (정리 필요)")
            return []
        
        # API 키 검증
        is_valid, message = verify_perplexity_api_key(api_key)
        
        if not is_valid:
            st.error(f"❌ API 키 검증 실패: {message}")
            return []
        
        st.success("✅ API 키 검증 완료")
        
        # 스마트 검색 쿼리 생성
        search_queries = generate_smart_search_queries(product_description, target_count=3)
        
        all_suppliers = []
        
        for i, query in enumerate(search_queries):
            try:
                suppliers = execute_single_search(query, api_key, max_results_per_query=5)
                if suppliers:
                    all_suppliers.extend(suppliers)
                    
                    # 중복 제거
                    unique_suppliers = remove_duplicate_suppliers(all_suppliers)
                    all_suppliers = unique_suppliers
                    
                    st.success(f"✅ 쿼리 {i+1}에서 {len(suppliers)}개 공급업체 발견 (총 {len(all_suppliers)}개)")
                
                # 잠시 대기 (API 제한 방지)
                time.sleep(2)
                
            except Exception as e:
                st.warning(f"⚠️ 쿼리 {i+1} 실행 중 오류: {str(e)}")
                continue
        
        return all_suppliers[:max_results]
        
    except Exception as e:
        st.error(f"❌ 제조사 검색 오류: {str(e)}")
        return []

def execute_single_search(query, api_key, max_results_per_query=5):
    """단일 검색 쿼리 실행 (OpenAI 클라이언트 사용)"""
    try:
        from openai import OpenAI
        
        # Perplexity API 클라이언트 생성
        client = OpenAI(
            api_key=api_key,
            base_url="https://api.perplexity.ai"
        )
        
        # 더 구체적이고 효과적인 프롬프트
        search_prompt = f"""
You are a professional sourcing agent. Find {max_results_per_query} REAL manufacturing companies for: {query}

CRITICAL REQUIREMENTS:
1. Only find ACTUAL manufacturers, not distributors or trading companies
2. Each company must have a working website
3. Focus on companies that actually produce the requested product
4. Include companies from China, Vietnam, Korea, Taiwan, and other manufacturing countries

For each company, provide information in this EXACT format (copy this format exactly):

COMPANY: [Full Company Name]
WEBSITE: [Complete website URL with http:// or https://]
EMAIL: [Contact email address]
PHONE: [Phone number]
LOCATION: [City, Country]
SPECIALIZATION: [What they manufacture]
COMPANY_TYPE: [Manufacturer/OEM/ODM]
ESTABLISHED: [Year established]
CERTIFICATIONS: [ISO, CE, RoHS, etc.]

EXAMPLE FORMAT:
COMPANY: ABC Electronics Manufacturing Co., Ltd.
WEBSITE: https://www.abcelectronics.com
EMAIL: sales@abcelectronics.com
PHONE: +86-755-1234-5678
LOCATION: Shenzhen, China
SPECIALIZATION: Electronic components and PCB manufacturing
COMPANY_TYPE: Manufacturer
ESTABLISHED: 2010
CERTIFICATIONS: ISO 9001, CE, RoHS

IMPORTANT: 
- Do not include companies without websites
- Do not include companies that are clearly just trading companies
- Focus on companies that actually manufacture the requested product
- Provide real, verifiable information
"""
        
        # 사용 가능한 모델들
        test_models = ["sonar-pro", "sonar-medium-online", "sonar-small-online"]
        
        # 각 모델로 시도
        for model in test_models:
            try:
                response = client.chat.completions.create(
                    model=model,
                    messages=[{"role": "user", "content": search_prompt}],
                    max_tokens=4000,
                    temperature=0.2
                )
                
                content = response.choices[0].message.content
                
                # 응답 파싱
                suppliers = parse_manufacturer_response(content)
                
                if suppliers:
                    return suppliers
                
            except Exception as e:
                error_msg = str(e)
                
                if "Invalid model" in error_msg or "model not found" in error_msg.lower():
                    continue  # 다음 모델 시도
                elif "authentication" in error_msg.lower() or "unauthorized" in error_msg.lower():
                    st.error("❌ API 키 인증 실패")
                    return []
                elif "rate limit" in error_msg.lower() or "quota" in error_msg.lower():
                    st.error("❌ API 요청 한도 초과")
                    return []
                else:
                    continue  # 다른 오류는 다음 모델 시도
        
        # 모든 모델에서 실패한 경우
        return []
        
    except ImportError:
        st.error("❌ OpenAI 라이브러리가 설치되지 않았습니다. 'pip install openai'를 실행하세요.")
        return []
    except Exception as e:
        st.error(f"❌ 검색 실행 중 오류: {str(e)}")
        return []

def parse_manufacturer_response(raw_text):
    """제조사 응답 파싱 (개선된 버전)"""
    suppliers = []
    
    try:
        # 더 유연한 패턴 매칭
        patterns = [
            # 완전한 형식
            r'COMPANY:\s*([^\n]+)\s*\nWEBSITE:\s*([^\n]+)\s*\nEMAIL:\s*([^\n]+)\s*\nPHONE:\s*([^\n]+)\s*\nLOCATION:\s*([^\n]+)\s*\nSPECIALIZATION:\s*([^\n]+)\s*\nCOMPANY_TYPE:\s*([^\n]+)\s*\nESTABLISHED:\s*([^\n]+)\s*\nCERTIFICATIONS:\s*([^\n]+)',
            # 기본 형식
            r'COMPANY:\s*([^\n]+)\s*\nWEBSITE:\s*([^\n]+)\s*\nEMAIL:\s*([^\n]+)\s*\nPHONE:\s*([^\n]+)\s*\nLOCATION:\s*([^\n]+)\s*\nSPECIALIZATION:\s*([^\n]+)',
            # 최소 형식
            r'COMPANY:\s*([^\n]+)\s*\nWEBSITE:\s*([^\n]+)\s*\nEMAIL:\s*([^\n]+)\s*\nPHONE:\s*([^\n]+)\s*\nLOCATION:\s*([^\n]+)',
            # 회사명과 웹사이트만
            r'COMPANY:\s*([^\n]+)\s*\nWEBSITE:\s*([^\n]+)'
        ]
        
        for pattern in patterns:
            matches = re.findall(pattern, raw_text, re.MULTILINE | re.IGNORECASE)
            
            for match in matches:
                supplier = {}
                
                if len(match) >= 2:
                    supplier['company_name'] = match[0].strip()
                    supplier['website'] = clean_url(match[1].strip())
                    
                    if len(match) > 2:
                        supplier['email'] = clean_email(match[2].strip())
                    if len(match) > 3:
                        supplier['phone'] = match[3].strip()
                    if len(match) > 4:
                        supplier['location'] = match[4].strip()
                    if len(match) > 5:
                        supplier['specialization'] = match[5].strip()
                    if len(match) > 6:
                        supplier['company_type'] = match[6].strip()
                    if len(match) > 7:
                        supplier['established'] = match[7].strip()
                    if len(match) > 8:
                        supplier['certifications'] = match[8].strip()
                    
                    # 기본값 설정
                    supplier.setdefault('email', '')
                    supplier.setdefault('phone', '')
                    supplier.setdefault('location', 'Unknown')
                    supplier.setdefault('specialization', 'Manufacturing')
                    supplier.setdefault('company_type', 'Manufacturer')
                    supplier.setdefault('established', 'Unknown')
                    supplier.setdefault('certifications', 'Not specified')
                    
                    # 유효성 검사
                    if is_valid_supplier(supplier):
                        suppliers.append(supplier)
        
        # 구조화된 파싱이 실패한 경우, 텍스트에서 정보 추출
        if not suppliers:
            suppliers = extract_suppliers_from_text(raw_text)
        
        return suppliers
        
    except Exception as e:
        return []

def extract_suppliers_from_text(text):
    """텍스트에서 공급업체 정보 추출 (백업 방법)"""
    suppliers = []
    
    try:
        # 회사명 패턴 찾기 (더 포괄적)
        company_patterns = [
            r'([A-Z][A-Za-z\s&.,]+(?:Ltd|Limited|Inc|Corp|Corporation|Company|Co|Manufacturing|Factory|Industries|Electronics|Technology|Industrial))',
            r'([A-Z][A-Za-z\s&.,]+(?:Group|International|Global|Trading|Manufacturing))',
            r'([A-Z][A-Za-z\s&.,]+(?:Co\.|Ltd\.|Inc\.|Corp\.))',
            r'([A-Z][A-Za-z\s&.,]+(?:Manufacturing|Factory|Industries))'
        ]
        
        # 웹사이트 패턴
        website_pattern = r'https?://[^\s\)\]\},;]+'
        
        # 이메일 패턴
        email_pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
        
        # 전화번호 패턴
        phone_pattern = r'[\+]?[0-9\s\-\(\)]{7,}'
        
        # 위치 패턴
        location_pattern = r'([A-Z][a-z]+,\s*[A-Z][a-z]+|[A-Z][a-z]+,\s*[A-Z]{2,3})'
        
        lines = text.split('\n')
        
        current_supplier = {}
        
        for line in lines:
            line = line.strip()
            if not line:
                continue
            
            # 회사명 찾기
            for pattern in company_patterns:
                match = re.search(pattern, line)
                if match:
                    company_name = match.group(1).strip()
                    # 이전 공급업체가 완성되면 저장
                    if current_supplier and current_supplier.get('company_name'):
                        if is_valid_supplier(current_supplier):
                            suppliers.append(current_supplier.copy())
                    # 새 공급업체 시작
                    current_supplier = {'company_name': company_name}
                    break
            
            # 웹사이트 찾기
            website_match = re.search(website_pattern, line)
            if website_match:
                current_supplier['website'] = clean_url(website_match.group(0))
            
            # 이메일 찾기
            email_match = re.search(email_pattern, line)
            if email_match:
                current_supplier['email'] = email_match.group(0)
            
            # 전화번호 찾기
            phone_match = re.search(phone_pattern, line)
            if phone_match:
                current_supplier['phone'] = phone_match.group(0)
            
            # 위치 찾기
            location_match = re.search(location_pattern, line)
            if location_match:
                current_supplier['location'] = location_match.group(1)
        
        # 마지막 공급업체 처리
        if current_supplier and current_supplier.get('company_name'):
            if is_valid_supplier(current_supplier):
                suppliers.append(current_supplier)
        
        # 기본값 설정
        for supplier in suppliers:
            supplier.setdefault('email', '')
            supplier.setdefault('phone', '')
            supplier.setdefault('location', 'Unknown')
            supplier.setdefault('specialization', 'Manufacturing')
            supplier.setdefault('company_type', 'Manufacturer')
            supplier.setdefault('established', 'Unknown')
            supplier.setdefault('certifications', 'Not specified')
        
        return suppliers
        
    except Exception as e:
        st.error(f"❌ 텍스트 추출 오류: {str(e)}")
        return []

def clean_url(url):
    """URL 정리"""
    if not url:
        return ""
    
    # 마크다운 링크 패턴 제거
    markdown_pattern = r'\[([^\]]+)\]\(([^)]+)\)'
    markdown_match = re.search(markdown_pattern, url)
    if markdown_match:
        url = markdown_match.group(2)
    
    # URL 끝의 불필요한 문자 제거
    url = re.sub(r'[)\]\},;]+$', '', url)
    
    # http:// 또는 https:// 추가
    if url and not url.startswith(('http://', 'https://')):
        if url.startswith('www.'):
            url = f"https://{url}"
        elif '.' in url:
            url = f"https://{url}"
    
    return url

def clean_email(email):
    """이메일 정리"""
    if not email:
        return ""
    
    # 이메일 패턴으로 검증
    email_pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
    match = re.search(email_pattern, email)
    return match.group(0) if match else ""

def is_valid_supplier(supplier):
    """공급업체 정보 유효성 검사 (개선된 버전)"""
    # 최소한 회사명이 있어야 함
    if not supplier.get('company_name'):
        return False
    
    # 회사명이 너무 짧으면 제외
    if len(supplier.get('company_name', '')) < 3:
        return False
    
    # 웹사이트나 이메일 중 하나는 있어야 함 (더 유연하게)
    if not supplier.get('website') and not supplier.get('email'):
        return False
    
    # 명백히 잘못된 회사명 제외
    invalid_names = ['unknown', 'n/a', 'none', 'example', 'sample', 'test']
    company_name_lower = supplier.get('company_name', '').lower()
    if any(invalid in company_name_lower for invalid in invalid_names):
        return False
    
    return True

def remove_duplicate_suppliers(suppliers):
    """중복 공급업체 제거"""
    seen = set()
    unique_suppliers = []
    
    for supplier in suppliers:
        # 회사명과 웹사이트로 중복 판단
        key = f"{supplier.get('company_name', '').lower()}_{supplier.get('website', '').lower()}"
        
        if key not in seen:
            seen.add(key)
            unique_suppliers.append(supplier)
    
    return unique_suppliers

def verify_supplier_website(website):
    """공급업체 웹사이트 검증 (간단한 버전)"""
    if not website:
        return False
    
    try:
        # 간단한 HTTP 요청으로 웹사이트 존재 확인
        response = requests.head(website, timeout=5, allow_redirects=True)
        return response.status_code == 200
    except:
        return False

def save_suppliers_to_database(suppliers, search_query, session_id):
    """공급업체를 데이터베이스에 저장 (개선된 버전)"""
    try:
        connection = connect_to_db()
        if not connection:
            st.error("❌ 데이터베이스 연결 실패")
            return 0
        
        cursor = connection.cursor()
        
        # 테이블 존재 확인 및 생성
        try:
            # 기존 테이블이 있는지 확인
            cursor.execute("SHOW TABLES LIKE 'sourcing_suppliers'")
            table_exists = cursor.fetchone()
            
            if table_exists:
                # 기존 테이블 삭제 (스키마 문제 해결을 위해)
                cursor.execute("DROP TABLE sourcing_suppliers")
                connection.commit()
            
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS sourcing_suppliers (
                    id INT AUTO_INCREMENT PRIMARY KEY,
                    company_name VARCHAR(255) NOT NULL,
                    website VARCHAR(500) DEFAULT '',
                    email VARCHAR(255) DEFAULT '',
                    phone VARCHAR(100) DEFAULT '',
                    location VARCHAR(255) DEFAULT '',
                    specialization VARCHAR(500) DEFAULT '',
                    company_type VARCHAR(100) DEFAULT '',
                    established VARCHAR(50) DEFAULT '',
                    certifications VARCHAR(500) DEFAULT '',
                    search_query VARCHAR(1000) DEFAULT '',
                    session_id INT DEFAULT NULL,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    INDEX idx_company_name (company_name),
                    INDEX idx_search_query (search_query(255)),
                    INDEX idx_session_id (session_id)
                ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
            """)
            connection.commit()
            st.success("✅ 데이터베이스 테이블 준비 완료")
        except Exception as table_error:
            st.error(f"❌ 테이블 생성 오류: {str(table_error)}")
            return 0
        
        saved_count = 0
        failed_count = 0
        
        for i, supplier in enumerate(suppliers):
            try:
                # 중복 확인
                cursor.execute("""
                    SELECT COUNT(*) FROM sourcing_suppliers 
                    WHERE company_name = %s AND website = %s
                """, (supplier.get('company_name', ''), supplier.get('website', '')))
                
                if cursor.fetchone()[0] > 0:
                    st.caption(f"⏭️ 중복 제외: {supplier.get('company_name', 'Unknown')}")
                    continue
                
                cursor.execute("""
                    INSERT INTO sourcing_suppliers (
                        company_name, website, email, phone, location, 
                        specialization, company_type, established, certifications,
                        search_query, session_id
                    ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                """, (
                    supplier.get('company_name', ''),
                    supplier.get('website', ''),
                    supplier.get('email', ''),
                    supplier.get('phone', ''),
                    supplier.get('location', ''),
                    supplier.get('specialization', ''),
                    supplier.get('company_type', ''),
                    supplier.get('established', ''),
                    supplier.get('certifications', ''),
                    search_query,
                    session_id
                ))
                saved_count += 1
                
                # 진행률 표시
                if (i + 1) % 5 == 0 or i == len(suppliers) - 1:
                    st.caption(f"💾 저장 진행률: {i+1}/{len(suppliers)}")
                
            except Exception as e:
                failed_count += 1
                st.warning(f"⚠️ 공급업체 저장 실패: {supplier.get('company_name', 'Unknown')} - {str(e)}")
                continue
        
        connection.commit()
        cursor.close()
        connection.close()
        
        if saved_count > 0:
            st.success(f"✅ {saved_count}개 공급업체 저장 완료")
        if failed_count > 0:
            st.warning(f"⚠️ {failed_count}개 공급업체 저장 실패")
        
        return saved_count
        
    except Exception as e:
        st.error(f"❌ 데이터베이스 저장 오류: {str(e)}")
        return 0

def get_saved_suppliers(session_id=None):
    """저장된 공급업체 조회"""
    try:
        connection = connect_to_db()
        if not connection:
            return []
        
        cursor = connection.cursor(dictionary=True)
        
        if session_id:
            cursor.execute("""
                SELECT * FROM sourcing_suppliers 
                WHERE session_id = %s 
                ORDER BY created_at DESC
            """, (session_id,))
        else:
            cursor.execute("""
                SELECT * FROM sourcing_suppliers 
                ORDER BY created_at DESC 
                LIMIT 100
            """)
        
        suppliers = cursor.fetchall()
        
        cursor.close()
        connection.close()
        
        return suppliers
        
    except Exception as e:
        st.error(f"❌ 공급업체 조회 오류: {str(e)}")
        return []

# ===== 데이터베이스 연결 함수 =====

def connect_to_db():
    """데이터베이스 연결"""
    try:
        connection = mysql.connector.connect(
            host=os.getenv('SQL_HOST'),
            user=os.getenv('SQL_USER'),
            password=os.getenv('SQL_PASSWORD'),
            database=os.getenv('SQL_DATABASE_NEWBIZ'),
            charset='utf8mb4',
            collation='utf8mb4_unicode_ci'
        )
        return connection
    except mysql.connector.Error as err:
        st.error(f"데이터베이스 연결 오류: {err}")
        return None

# ===== 메인 UI =====

def main():
    """메인 애플리케이션"""
    
    # 사이드바 설정
    with st.sidebar:
        st.markdown("## 🔧 시스템 상태")
        
        # API 키 상태 확인
        raw_perplexity_key = os.environ.get('PERPLEXITY_API_KEY', '')
        perplexity_key = clean_api_key(raw_perplexity_key)
        
        if perplexity_key and len(perplexity_key) > 10:
            st.success("✅ Perplexity API 키 설정됨")
            
            # API 키 검증 버튼
            if st.button("🔍 API 키 검증", key="verify_api_key"):
                with st.spinner("API 키 검증 중..."):
                    is_valid, message = verify_perplexity_api_key(perplexity_key)
                    if is_valid:
                        st.success("✅ API 키가 유효합니다!")
                    else:
                        st.error(f"❌ API 키 검증 실패: {message}")
        else:
            st.error("❌ Perplexity API 키 필요")
            
            with st.expander("🔑 API 키 설정"):
                temp_key = st.text_input("Perplexity API Key", type="password")
                if st.button("임시 키 설정"):
                    if temp_key.strip():
                        cleaned_key = clean_api_key(temp_key)
                        os.environ['PERPLEXITY_API_KEY'] = cleaned_key
                        st.success("✅ API 키 설정됨")
                        st.rerun()
                
                st.caption("💡 API 키 발급 방법:")
                st.caption("1. https://www.perplexity.ai/settings/api 방문")
                st.caption("2. 로그인 후 API 키 생성")
                st.caption("3. 키는 'pplx-'로 시작해야 함")
        
        # 데이터베이스 상태
        try:
            connection = connect_to_db()
            if connection:
                st.success("✅ 데이터베이스 연결됨")
                connection.close()
            else:
                st.error("❌ 데이터베이스 연결 실패")
        except:
            st.error("❌ 데이터베이스 연결 실패")
        
        st.markdown("---")
        st.markdown("## 📊 사용 통계")
        
        # 저장된 공급업체 수
        try:
            connection = connect_to_db()
            if connection:
                cursor = connection.cursor()
                cursor.execute("SELECT COUNT(*) FROM sourcing_suppliers")
                total_suppliers = cursor.fetchone()[0]
                st.metric("총 공급업체", total_suppliers)
                
                cursor.execute("SELECT COUNT(*) FROM sourcing_suppliers WHERE created_at >= DATE_SUB(NOW(), INTERVAL 1 DAY)")
                today_suppliers = cursor.fetchone()[0]
                st.metric("오늘 발견", today_suppliers)
                
                cursor.close()
                connection.close()
        except:
            st.metric("총 공급업체", "확인 불가")
    
    # 메인 탭 구성
    tab1, tab2, tab3 = st.tabs(["🔍 제품 소싱", "📋 발견된 공급업체", "📊 분석 결과"])
    
    # ===== 탭 1: 제품 소싱 =====
    with tab1:
        st.markdown("## 🔍 제품 소싱 검색")
        
        # 검색 예시
        with st.expander("💡 검색 예시 및 팁", expanded=False):
            st.markdown("""
            **효과적인 검색 예시:**
            - "LED 조명 제조업체"
            - "스마트폰 케이스 공장"
            - "전자 부품 제조사"
            - "의류 제조업체"
            - "기계 부품 공급업체"
            
            **검색 팁:**
            - 구체적인 제품명 사용
            - "제조업체", "공장", "제조사" 키워드 추가
            - 영어 키워드 혼용: "LED lighting manufacturer"
            - 재질 명시: "플라스틱 케이스 제조업체"
            """)
        
        # 검색 폼
        with st.form("sourcing_form"):
            col1, col2 = st.columns([2, 1])
            
            with col1:
                product_description = st.text_area(
                    "제품 설명을 상세히 입력하세요:",
                    placeholder="예: LED 조명 제조업체, 스마트폰 케이스 공장, 전자 부품 제조사 등",
                    height=100,
                    help="구체적으로 어떤 제품을 찾고 있는지 설명해주세요."
                )
                
                search_options = st.multiselect(
                    "검색 지역:",
                    ["중국", "베트남", "한국", "대만", "일본", "인도", "태국"],
                    default=["중국", "베트남"],
                    help="어느 지역의 제조사를 찾을지 선택하세요"
                )
            
            with col2:
                max_results = st.slider("최대 결과 수", 5, 30, 15, help="찾을 공급업체의 최대 개수")
                
                search_depth = st.selectbox(
                    "검색 깊이:",
                    ["기본 (빠름)", "상세 (보통)", "포괄 (느림)"],
                    help="검색 깊이가 깊을수록 더 많은 결과를 찾지만 시간이 오래 걸립니다"
                )
                
                st.markdown("### 🔍 검색 팁")
                st.markdown("""
                **효과적인 검색을 위한 팁:**
                - 구체적인 제품명 사용
                - 재질이나 규격 명시
                - 용도나 특성 포함
                - 영어 키워드 혼용
                """)
            
            submitted = st.form_submit_button("🔍 제품 소싱 시작", type="primary")
        
        # 검색 실행
        if submitted:
            if not product_description.strip():
                st.error("❌ 제품 설명을 입력해주세요.")
            else:
                # 세션 ID 생성
                session_id = int(time.time())
                
                with st.spinner("🔍 제품 소싱 중..."):
                    # 검색 쿼리 생성
                    base_query = product_description
                    if search_options:
                        regions = " ".join(search_options)
                        base_query = f"{product_description} {regions}"
                    
                    # 검색 실행
                    suppliers = search_manufacturers_with_perplexity(base_query, max_results)
                    
                    if suppliers:
                        st.success(f"🎉 {len(suppliers)}개의 공급업체를 발견했습니다!")
                        
                        # 데이터베이스에 저장
                        saved_count = save_suppliers_to_database(suppliers, base_query, session_id)
                        if saved_count > 0:
                            st.success(f"💾 {saved_count}개 공급업체가 데이터베이스에 저장되었습니다.")
                        
                        # 세션 ID 저장
                        st.session_state.last_session_id = session_id
                        
                        # 결과 표시
                        display_suppliers(suppliers)
                        
                    else:
                        st.warning("⚠️ 검색 조건에 맞는 공급업체를 찾지 못했습니다.")
                        
                        with st.expander("🔧 검색 개선 제안"):
                            st.markdown("""
                            **더 나은 결과를 위한 제안:**
                            1. **더 구체적인 제품명 사용**: "스마트폰 케이스" → "iPhone 15 Pro 케이스"
                            2. **영어 키워드 추가**: "LED 조명" → "LED lighting manufacturer"
                            3. **재질 명시**: "플라스틱 케이스", "실리콘 케이스"
                            4. **용도 포함**: "자동차용 LED", "가정용 조명"
                            5. **규격 추가**: "5V LED", "12V 전원 공급기"
                            """)
    
    # ===== 탭 2: 발견된 공급업체 =====
    with tab2:
        st.markdown("## 📋 발견된 공급업체 목록")
        
        # 필터링 옵션
        col1, col2, col3 = st.columns(3)
        
        with col1:
            search_filter = st.text_input("🔍 공급업체명 검색", placeholder="회사명으로 검색")
        
        with col2:
            location_filter = st.selectbox("🌍 지역 필터", ["전체", "중국", "베트남", "한국", "대만", "일본", "인도", "기타"])
        
        with col3:
            sort_by = st.selectbox("🔄 정렬", ["최신순", "회사명순", "지역순"])
        
        # 공급업체 조회
        suppliers = get_saved_suppliers()
        
        if suppliers:
            # 필터링
            filtered_suppliers = suppliers
            
            if search_filter:
                filtered_suppliers = [
                    s for s in filtered_suppliers 
                    if search_filter.lower() in s.get('company_name', '').lower()
                ]
            
            if location_filter != "전체":
                filtered_suppliers = [
                    s for s in filtered_suppliers 
                    if location_filter.lower() in s.get('location', '').lower()
                ]
            
            # 정렬
            if sort_by == "회사명순":
                filtered_suppliers.sort(key=lambda x: x.get('company_name', ''))
            elif sort_by == "지역순":
                filtered_suppliers.sort(key=lambda x: x.get('location', ''))
            else:  # 최신순
                filtered_suppliers.sort(key=lambda x: x.get('created_at', ''), reverse=True)
            
            st.success(f"📊 총 {len(filtered_suppliers)}개의 공급업체가 있습니다.")
            
            # 공급업체 목록 표시
            for i, supplier in enumerate(filtered_suppliers):
                company_name = supplier.get('company_name', 'Unknown Company')
                
                with st.expander(f"🏢 {company_name}"):
                    display_supplier_card(supplier, i)
        
        else:
            st.info("🔍 아직 발견된 공급업체가 없습니다. 먼저 제품 소싱을 실행해주세요.")
    
    # ===== 탭 3: 분석 결과 =====
    with tab3:
        st.markdown("## 📊 소싱 분석 결과")
        
        suppliers = get_saved_suppliers()
        
        if suppliers:
            # 통계 분석
            col1, col2, col3, col4 = st.columns(4)
            
            with col1:
                st.metric("총 공급업체", len(suppliers))
            
            with col2:
                # 지역별 통계
                locations = [s.get('location', 'Unknown') for s in suppliers]
                china_count = sum(1 for loc in locations if 'china' in loc.lower())
                st.metric("중국 업체", china_count)
            
            with col3:
                vietnam_count = sum(1 for loc in locations if 'vietnam' in loc.lower())
                st.metric("베트남 업체", vietnam_count)
            
            with col4:
                korea_count = sum(1 for loc in locations if 'korea' in loc.lower())
                st.metric("한국 업체", korea_count)
            
            # 지역별 분포 차트
            st.markdown("### 🌍 지역별 공급업체 분포")
            
            location_counts = {}
            for supplier in suppliers:
                location = supplier.get('location', 'Unknown')
                # 국가 추출
                country = extract_country(location)
                location_counts[country] = location_counts.get(country, 0) + 1
            
            if location_counts:
                df_location = pd.DataFrame(list(location_counts.items()), columns=['국가', '업체 수'])
                st.bar_chart(df_location.set_index('국가'))
            
            # 회사 유형별 분석
            st.markdown("### 🏭 회사 유형별 분석")
            
            company_types = [s.get('company_type', 'Unknown') for s in suppliers]
            type_counts = {}
            for company_type in company_types:
                type_counts[company_type] = type_counts.get(company_type, 0) + 1
            
            if type_counts:
                df_types = pd.DataFrame(list(type_counts.items()), columns=['회사 유형', '업체 수'])
                st.bar_chart(df_types.set_index('회사 유형'))
            
            # 최근 발견 추이
            st.markdown("### 📈 최근 발견 추이")
            
            try:
                connection = connect_to_db()
                if connection:
                    cursor = connection.cursor()
                    cursor.execute("""
                        SELECT DATE(created_at) as date, COUNT(*) as count 
                        FROM sourcing_suppliers 
                        WHERE created_at >= DATE_SUB(NOW(), INTERVAL 7 DAY)
                        GROUP BY DATE(created_at)
                        ORDER BY date
                    """)
                    
                    daily_data = cursor.fetchall()
                    cursor.close()
                    connection.close()
                    
                    if daily_data:
                        df_daily = pd.DataFrame(daily_data, columns=['날짜', '발견 수'])
                        st.line_chart(df_daily.set_index('날짜'))
                    
            except Exception as e:
                st.warning(f"⚠️ 일별 통계 조회 실패: {str(e)}")
        
        else:
            st.info("📊 분석할 데이터가 없습니다. 먼저 제품 소싱을 실행해주세요.")

def display_suppliers(suppliers):
    """공급업체 목록 표시"""
    st.markdown("### 🏢 발견된 공급업체")
    
    for i, supplier in enumerate(suppliers, 1):
        # 고유한 키 생성
        company_name = supplier.get('company_name', 'Unknown Company')
        
        with st.expander(f"{i}. {company_name}"):
            display_supplier_card(supplier, i)

def display_supplier_card(supplier, index=None):
    """개별 공급업체 카드 표시"""
    col1, col2 = st.columns([2, 1])
    
    with col1:
        st.markdown(f"**🏢 회사명:** {supplier.get('company_name', 'N/A')}")
        
        if supplier.get('website'):
            st.markdown(f"**🌐 웹사이트:** [{supplier['website']}]({supplier['website']})")
        
        if supplier.get('email'):
            st.markdown(f"**📧 이메일:** {supplier['email']}")
        
        if supplier.get('phone'):
            st.markdown(f"**📞 전화번호:** {supplier['phone']}")
        
        if supplier.get('location'):
            st.markdown(f"**📍 위치:** {supplier['location']}")
        
        if supplier.get('specialization'):
            st.markdown(f"**🏭 전문분야:** {supplier['specialization']}")
    
    with col2:
        if supplier.get('company_type'):
            st.markdown(f"**🏢 유형:** {supplier['company_type']}")
        
        if supplier.get('established'):
            st.markdown(f"**📅 설립:** {supplier['established']}")
        
        if supplier.get('certifications'):
            st.markdown(f"**✅ 인증:** {supplier['certifications']}")
        
        # 웹사이트 검증 버튼
        if supplier.get('website'):
            # 고유한 키 생성 (인덱스 + 회사명 + ID 사용)
            company_name = supplier.get('company_name', 'Unknown')
            supplier_id = supplier.get('id', 'unknown')
            index_str = f"idx_{index}" if index is not None else "no_idx"
            # 안전한 키 생성 (특수문자 제거 및 길이 제한)
            safe_company_name = re.sub(r'[^a-zA-Z0-9]', '_', company_name)[:20]
            unique_key = f"verify_{index_str}_{safe_company_name}_{supplier_id}"[:50]
            
            if st.button(f"🔍 웹사이트 확인", key=unique_key):
                is_valid = verify_supplier_website(supplier['website'])
                if is_valid:
                    st.success("✅ 웹사이트 접속 가능")
                else:
                    st.error("❌ 웹사이트 접속 불가")

def extract_country(location):
    """위치에서 국가 추출"""
    if not location:
        return "Unknown"
    
    location_lower = location.lower()
    
    country_mapping = {
        'china': '중국',
        'chinese': '중국',
        'vietnam': '베트남',
        'vietnamese': '베트남',
        'korea': '한국',
        'korean': '한국',
        'taiwan': '대만',
        'japan': '일본',
        'japanese': '일본',
        'india': '인도',
        'indian': '인도',
        'thailand': '태국',
        'thai': '태국',
        'malaysia': '말레이시아',
        'indonesia': '인도네시아',
        'philippines': '필리핀',
        'singapore': '싱가포르'
    }
    
    for english, korean in country_mapping.items():
        if english in location_lower:
            return korean
    
    return "기타"

# 푸터
st.markdown("---")
st.markdown("""
<div style='text-align: center; color: #666; padding: 20px;'>
    <p>🔍 <strong>AI 제품 소싱 시스템</strong></p>
    <p>실시간 웹 검색 기반 제조사 및 공급업체 발굴 | Powered by Perplexity AI</p>
</div>
""", unsafe_allow_html=True)

if __name__ == "__main__":
    main() 