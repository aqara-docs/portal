import streamlit as st
import pandas as pd
import os
from datetime import datetime
import mysql.connector
from dotenv import load_dotenv
from openai import OpenAI
import anthropic
from langchain_openai import OpenAI as LangOpenAI
from langchain_anthropic import ChatAnthropic
import base64
import random
from datetime import timedelta
import time
import streamlit.components.v1 as components

st.set_page_config(page_title="📚 전사 독서경영 ", layout="wide")

# 환경 변수 로드
load_dotenv()

# 디버깅: OpenAI API 키 상태 확인
openai_key = os.getenv('OPENAI_API_KEY')
#print(f"[DEBUG] OpenAI API Key 상태: {openai_key[:10] if openai_key else 'None'}...")
#print(f"[DEBUG] OpenAI API Key 길이: {len(openai_key) if openai_key else 0}")

st.title("📚 전사 독서경영 통합 관리")
# 인증 기능 (간단한 비밀번호 보호)
if 'authenticated' not in st.session_state:
    st.session_state.authenticated = False

admin_pw = os.getenv('ADMIN_PASSWORD')
if not admin_pw:
    st.error('환경변수(ADMIN_PASSWORD)가 설정되어 있지 않습니다. .env 파일을 확인하세요.')
    st.stop()

if not st.session_state.authenticated:
    password = st.text_input("관리자 비밀번호를 입력하세요", type="password")
    if password == admin_pw:
        st.session_state.authenticated = True
        st.rerun()
    else:
        if password:  # 비밀번호가 입력된 경우에만 오류 메시지 표시
            st.error("관리자 권한이 필요합니다")
        st.stop()

# 모델 선택 및 API 키 확인
if 'selected_model' not in st.session_state:
    st.session_state.selected_model = 'claude-3-7-sonnet-latest'

# 모델 선택 UI (Claude 최신 버전이 디폴트)
available_models = []
has_anthropic_key = os.environ.get('ANTHROPIC_API_KEY') is not None
if has_anthropic_key:
    available_models.extend([
        'claude-3-7-sonnet-latest',
        'claude-3-5-sonnet-latest',
        'claude-3-5-haiku-latest',
    ])
has_openai_key = os.environ.get('OPENAI_API_KEY') is not None
if has_openai_key:
    available_models.extend(['gpt-4o', 'gpt-4o-mini'])
if not available_models:
    available_models = ['claude-3-7-sonnet-latest']

# 모델 선택 (다른 세션 상태에 영향을 주지 않도록 안전하게 처리)
selected_model = st.selectbox(
    'AI 모델 선택',
    options=available_models,
    index=available_models.index(st.session_state.selected_model) if st.session_state.selected_model in available_models else 0,
    help='Claude(Anthropic)는 ANTHROPIC_API_KEY, OpenAI는 OPENAI_API_KEY 필요'
)
# 모델이 실제로 변경된 경우에만 세션 상태 업데이트
if selected_model != st.session_state.selected_model:
    st.session_state.selected_model = selected_model

# DB 연결 함수
def connect_to_db():
    return mysql.connector.connect(
        user=os.getenv('SQL_USER'),
        password=os.getenv('SQL_PASSWORD'),
        host=os.getenv('SQL_HOST'),
        database=os.getenv('SQL_DATABASE_NEWBIZ'),
        charset='utf8mb4',
        collation='utf8mb4_unicode_ci'
    )

def save_material(book_title, file_name, content, type):
    conn = connect_to_db()
    cursor = conn.cursor()
    try:
        # 먼저 테이블 구조 확인
        cursor.execute("DESCRIBE reading_materials")
        table_info = cursor.fetchall()
        content_column_info = None
        for column in table_info:
            if column[0] == 'content':
                content_column_info = column
                break
        
        # content 컬럼의 최대 길이 확인 및 제한
        max_length = None
        if content_column_info:
            column_type = content_column_info[1].lower()
            if 'varchar' in column_type:
                # VARCHAR(n) 형태에서 n 추출
                import re
                match = re.search(r'varchar\((\d+)\)', column_type)
                if match:
                    max_length = int(match.group(1))
            elif column_type in ['text']:
                max_length = 65535  # TEXT 타입의 최대 길이
            elif column_type in ['mediumtext']:
                max_length = 16777215  # MEDIUMTEXT 타입의 최대 길이
            elif column_type in ['longtext']:
                max_length = 4294967295  # LONGTEXT 타입의 최대 길이
        
        # 내용이 너무 길면 자르기
        original_length = len(content)
        if max_length and len(content) > max_length:
            content = content[:max_length-100] + "\n\n[내용이 너무 길어서 일부가 잘렸습니다.]"
            st.warning(f"내용이 너무 길어서 {original_length}자에서 {len(content)}자로 잘렸습니다.")
        
        cursor.execute(
            "INSERT INTO reading_materials (book_title, file_name, content, type) VALUES (%s, %s, %s, %s)",
            (book_title, file_name, content, type)
        )
        conn.commit()
        
        # 컬럼 타입 정보 표시
        if content_column_info:
            st.info(f"DB 저장 완료 (content 컬럼 타입: {content_column_info[1]}, 저장된 내용 길이: {len(content)}자)")
        
        return True
    except Exception as e:
        st.error(f"DB 저장 중 오류: {str(e)}")
        if content_column_info:
            st.error(f"현재 content 컬럼 타입: {content_column_info[1]}")
            st.error(f"저장하려는 내용 길이: {len(content)}자")
        conn.rollback()
        return False
    finally:
        cursor.close()
        conn.close()

def get_materials(material_type):
    conn = connect_to_db()
    cursor = conn.cursor(dictionary=True)
    try:
        cursor.execute(
            "SELECT id, book_title, file_name, content, created_at FROM reading_materials WHERE type = %s ORDER BY created_at DESC",
            (material_type,)
        )
        return cursor.fetchall()
    finally:
        cursor.close()
        conn.close()

# 독서토론 기록 저장 함수
def save_reading_discussion_record(book_title, source_file_name, content_type, ai_content, 
                                  audio_data=None, audio_filename=None, fable_type=None, 
                                  model_used=None, extra_prompt=None, opening_ment=None, 
                                  next_topic=None, previous_topic=None):
    """독서토론 AI 생성 콘텐츠 및 음성을 DB에 저장"""
    conn = connect_to_db()
    cursor = conn.cursor()
    try:
        cursor.execute("""
            INSERT INTO reading_discussion_records 
            (book_title, source_file_name, content_type, ai_content, audio_data, 
             audio_filename, fable_type, model_used, extra_prompt, opening_ment, 
             next_topic, previous_topic) 
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
        """, (book_title, source_file_name, content_type, ai_content, audio_data,
              audio_filename, fable_type, model_used, extra_prompt, opening_ment,
              next_topic, previous_topic))
        conn.commit()
        return True
    except Exception as e:
        st.error(f"독서토론 기록 저장 중 오류: {str(e)}")
        conn.rollback()
        return False
    finally:
        cursor.close()
        conn.close()

# 독서토론 기록 조회 함수
def get_reading_discussion_records(content_type=None, book_title=None):
    """저장된 독서토론 기록 조회"""
    conn = connect_to_db()
    cursor = conn.cursor(dictionary=True)
    try:
        if content_type and book_title:
            cursor.execute("""
                SELECT * FROM reading_discussion_records 
                WHERE content_type = %s AND book_title = %s 
                ORDER BY created_at DESC
            """, (content_type, book_title))
        elif content_type:
            cursor.execute("""
                SELECT * FROM reading_discussion_records 
                WHERE content_type = %s 
                ORDER BY created_at DESC
            """, (content_type,))
        elif book_title:
            cursor.execute("""
                SELECT * FROM reading_discussion_records 
                WHERE book_title = %s 
                ORDER BY created_at DESC
            """, (book_title,))
        else:
            cursor.execute("""
                SELECT * FROM reading_discussion_records 
                ORDER BY created_at DESC
            """)
        return cursor.fetchall()
    except Exception as e:
        st.error(f"독서토론 기록 조회 중 오류: {str(e)}")
        return []
    finally:
        cursor.close()
        conn.close()

# 독서토론 기록 삭제 함수
def delete_reading_discussion_record(record_id):
    """독서토론 기록 삭제"""
    conn = connect_to_db()
    cursor = conn.cursor()
    try:
        cursor.execute("DELETE FROM reading_discussion_records WHERE id = %s", (record_id,))
        conn.commit()
        return cursor.rowcount > 0  # 삭제된 행이 있으면 True
    except Exception as e:
        st.error(f"독서토론 기록 삭제 중 오류: {str(e)}")
        conn.rollback()
        return False
    finally:
        cursor.close()
        conn.close()

# 우화 생성 함수 (Claude/OpenAI 모두 지원)
def ai_generate_fable(text, fable_type, model_name, extra_prompt=None):
    # 각 우화 스타일별 구체적인 지시사항
    fable_instructions = {
        "하모니아": (
            "당신은 동서양의 위대한 사상가들의 대화를 구성하는 전문가입니다. "
            "다음 각 그룹에서 랜덤하게 1명씩 선택하여 3분 분량의 심오하고 통찰력 있는 대화를 구성합니다:\n"
            "1. 4대 성인 중 1명 (예수님, 부처님, 공자님, 소크라테스님)\n"
            "2. 중국 고대 사상가 중 1명 (장자님, 노자님, 맹자님, 순자님, 묵자님, 한비자님, 공손룡님)\n"
            "3. 동양의 전략가 중 1명 (제갈량님, 장량님, 손무님)\n"
            "4. 기업 및 인재 경영의 대가 중 1명 (피터 드러커님, 이나모리 가즈오님, 데일 카네기님)\n"
            "5. 경영전략의 대가 중 1명 (마이클 포터님, 헨리 민츠버그님, 게리 하멜님, 클레이튼 크리스텐슨님)\n"
            "6. 게임이론의 대가 중 1명 (존 폰노이만님, 존 내쉬님, 토마스 셀링님, 애덤 브랜드버거님)\n"
            "7. AI 4대 석학 중 1명 (제프리 힌튼님, 얀 르쿤님, 요슈아 벤지오님, 앤드류 응님)\n"
            "각 인물의 고유한 철학과 사상을 정확히 반영하여 존댓말로 대화를 구성하고, "
            "서로를 반드시 '님'을 붙여 호칭하며(예: '공자님', '드러커님', '힌튼님'), "
            "대화 시작 시 '참석자: [선택된 인물] ([분야])' 형태로 간략하게 소개해 주세요. "
            "예: '참석자: 예수님 (4대 성인), 맹자님 (동양 사상가), 제갈량님 (고대 전략가), 이나모리 가즈오님 (회사/인간 경영의 대가), 마이클 포터님 (경영 전략가), 존 내쉬님 (게임이론가), 제프리 힌튼님 (AI 석학)'\n"
            "각 인물의 주요 사상과 특징을 반영하여 대화를 구성해 주세요.\n"
            "대화가 끝난 후, 요약 내용의 핵심 주제와 관련된 '오늘의 명언'을 한글과 영어로 제시해 주세요.\n"
            "- 맹자님: 성선설, 왕도정치\n"
            "- 순자님: 성악설, 예치주의\n"
            "- 묵자님: 겸애(兼愛)와 비공(非攻)\n"
            "- 한비자님: 법가사상, 법치주의\n"
            "- 공손룡님: 명가(名家), 논리철학\n"
            "- 예수님: 사랑, 용서, 구원\n"
            "- 부처님: 중도, 연기, 해탈\n"
            "- 공자님: 인(仁), 예(禮), 도덕\n"
            "- 소크라테스님: 문답법, 덕의 추구\n"
            "- 제갈량님: 지략, 충의, 인재경영\n"
            "- 장량님: 모략, 은인자중\n"
            "- 손무님: 군사전략, 승리의 지혜\n"
            "- 드러커님: 현대경영이론, 자기관리\n"
            "- 이나모리님: 경영철학, 인간존중\n"
            "- 카네기님: 인간관계, 리더십\n"
            "- 포터님: 경쟁전략, 가치사슬\n"
            "- 민츠버그님: 전략형성, 조직설계\n"
            "- 하멜님: 혁신, 핵심역량\n"
            "- 크리스텐슨님: 파괴적 혁신\n"
            "- 폰노이만님: 게임이론 기초, 수학적 접근\n"
            "- 내쉬님: 균형이론, 협상전략\n"
            "- 셀링님: 갈등해결, 전략적 사고\n"
            "- 브랜드버거님: 게임이론 응용, 경쟁전략\n"
            "- 힌튼님: 딥러닝의 창시자, 역전파 알고리즘, 신경망 기반 AI\n"
            "- 르쿤님: 합성곱 신경망(CNN), 컴퓨터 비전, AI 기술 한계 평가\n"
            "- 벤지오님: 순환 신경망(RNN), Turing Award, AI 안전성과 윤리\n"
            "- 응님: Google Brain, 머신러닝 대중화, AI 교육 혁신"
        ),
        "이솝우화": (
            "아래 요약 내용을 바탕으로 이솝우화 스타일의 1분 30초 분량 대화체 우화를 만들어 주세요. "
            "동물들이 주인공이 되어 생생한 대화를 나누며, 마지막에 명확한 교훈을 제시하는 형식으로 작성해 주세요. "
            "존댓말을 사용하고, 간결하면서도 깊은 의미를 담아주세요. "
            "이야기 마지막에는 '오늘의 명언'으로 요약 내용과 관련된 1줄 명언을 한글과 영어로 작성해 주세요."
        ),
        "탈무드": (
            "아래 요약 내용을 바탕으로 탈무드 스타일의 1분 30초 분량 대화체 지혜 이야기를 만들어 주세요. "
            "랍비와 제자들의 생생한 대화 형식으로 구성하고, 질문과 답변을 통해 깊은 통찰을 전달해 주세요. "
            "유대 지혜의 전통에 맞게 실용적이면서도 철학적인 교훈을 담아주세요. "
            "이야기 마지막에는 '오늘의 명언'으로 요약 내용과 관련된 1줄 명언을 한글과 영어로 작성해 주세요."
        ),
        "성경이야기": (
            "아래 요약 내용을 바탕으로 성경 스타일의 1분 30초 분량 대화체 비유 이야기를 만들어 주세요. "
            "등장인물들의 생생한 대화를 통해 일상적인 상황에서 영적, 도덕적 교훈을 전달하는 형식으로 작성해 주세요. "
            "사랑, 용서, 겸손, 섬김의 가치를 반영하여 따뜻하고 감동적인 대화로 구성해 주세요. "
            "이야기 마지막에는 '오늘의 명언'으로 요약 내용과 관련된 1줄 명언을 한글과 영어로 작성해 주세요."
        ),
        "4대 성인 대화(예수님, 부처님, 공자님, 소크라테스님)": (
            "아래 요약 내용을 바탕으로 4대 성인이 대화하는 1분 30초 분량의 이야기를 만들어 주세요. "
            "각 성인의 고유한 사상을 반영한 생생한 대화로 구성해야 합니다:\n"
            "- 예수님: 사랑과 용서, 겸손과 섬김의 가치를 담은 따뜻한 말투\n"
            "- 부처님: 자비와 깨달음, 중도와 무상의 가르침을 담은 자비로운 말투\n"
            "- 공자님: 인(仁)과 예(禮), 수신제가치국평천하의 도덕적 가르침을 담은 온화한 말투\n"
            "- 소크라테스님: '나는 아무것도 모른다'는 겸손함과 대화를 통한 진리 탐구를 담은 지혜로운 말투\n"
            "중요: 각 성인이 서로를 호칭할 때는 반드시 '소크라테스님', '공자님', '예수님', '부처님'이라는 정중한 호칭을 사용해 주세요.\n"
            "각자의 관점에서 주제에 대해 대화하며, 서로 다른 접근법으로 같은 진리에 도달하는 과정을 보여주세요. "
            "이야기 마지막에는 '오늘의 명언'으로 요약 내용과 관련된 1줄 명언을 한글과 영어로 작성해 주세요."
        ),
        "장자 이야기": (
            "아래 요약 내용을 바탕으로 장자 스타일의 1분 30초 분량 대화체 우화를 만들어 주세요. "
            "장자의 철학인 무위자연(無爲自然), 상대성, 자유로운 정신을 반영하여 "
            "등장인물들의 기발하고 상상력이 풍부한 대화로 구성해 주세요. "
            "고정관념을 뒤흔들고 새로운 관점을 제시하는 장자 특유의 역설적 지혜를 대화로 담아주세요. "
            "이야기 마지막에는 '오늘의 명언'으로 요약 내용과 관련된 1줄 명언을 한글과 영어로 작성해 주세요."
        ),
        "노자의 도덕경": (
            "아래 요약 내용을 바탕으로 노자의 도덕경 스타일의 1분 30초 분량 대화체 이야기를 만들어 주세요. "
            "노자의 철학인 도(道), 무위(無爲), 음양(陰陽)의 조화, 겸손함을 반영하여 "
            "노자와 제자 또는 구도자들의 깊이 있는 대화로 구성해 주세요. "
            "물과 같이 부드럽고 겸손하지만 강한 힘을 지닌 지혜, 자연의 순리를 따르는 가르침을 대화로 담아주세요. "
            "이야기 마지막에는 '오늘의 명언'으로 요약 내용과 관련된 1줄 명언을 한글과 영어로 작성해 주세요."
        ),
        "삼국지의 제갈량": (
            "제공된 요약 내용의 핵심 주제, 문제점, 해결방안을 철저히 분석한 후, "
            "그 내용을 삼국지의 제갈량 스타일로 재해석하여 1분 30초 분량의 대화체 이야기를 만들어 주세요. "
            "요약 내용의 상황을 삼국지 시대로 비유하되, 반드시 원본 요약의 핵심 메시지와 교훈을 유지해야 합니다. "
            "제갈량과 유비, 관우, 장비 등이 요약 내용의 문제를 삼국지 시대의 관점에서 논의하고 해결책을 찾는 형식으로 구성하고, "
            "제갈량의 뛰어난 지략과 전략적 사고를 통해 요약 내용의 핵심을 전달해 주세요. "
            "중요: 삼국지 일반 이야기가 아닌, 요약 내용을 삼국지 스타일로 표현한 우화를 만들어야 합니다. "
            "이야기 마지막에는 '오늘의 명언'으로 요약 내용과 관련된 1줄 명언을 한글과 영어로 작성해 주세요."
        ),
        "초한지의 장량": (
            "제공된 요약 내용의 핵심 주제, 문제점, 해결방안을 철저히 분석한 후, "
            "그 내용을 초한지의 장량(장자방) 스타일로 재해석하여 1분 30초 분량의 대화체 이야기를 만들어 주세요. "
            "요약 내용의 상황을 초한지 시대로 비유하되, 반드시 원본 요약의 핵심 메시지와 교훈을 유지해야 합니다. "
            "장량과 유방(한고조), 소하, 한신 등이 요약 내용의 문제를 초한지 시대의 관점에서 논의하고 해결책을 찾는 형식으로 구성하고, "
            "장량의 탁월한 모략과 지략, 은인자중의 지혜를 통해 요약 내용의 핵심을 전달해 주세요. "
            "중요: 초한지 일반 이야기가 아닌, 요약 내용을 초한지 스타일로 표현한 우화를 만들어야 합니다. "
            "이야기 마지막에는 '오늘의 명언'으로 요약 내용과 관련된 1줄 명언을 한글과 영어로 작성해 주세요."
        ),
        "주역": (
            "아래 요약 내용을 바탕으로 주역(易經) 스타일의 1분 30초 분량 대화체 이야기를 만들어 주세요. "
            "중요: 반드시 요약 내용의 핵심 주제, 상황, 문제점, 해결방안을 세밀하게 분석한 후, "
            "그 내용과 정확히 부합하는 64괘 중 하나를 선정해야 합니다. 임의로 괘를 선택하지 마세요. "
            "선정 과정: 1) 요약 내용의 핵심 키워드 추출 2) 해당 상황의 성격 분석 3) 가장 적합한 괘 선정 4) 선정 이유 간략히 설명 "
            "선택한 괘의 이름, 의미, 그리고 왜 이 괘가 요약 내용과 일치하는지 명확히 설명해 주세요. "
            "그 괘의 철학과 해석을 바탕으로 주역의 대가와 구도자, 또는 현자들의 깊이 있는 대화로 구성해 주세요. "
            "음양의 조화, 변화의 이치, 때의 중요성, 순응과 변통의 지혜를 대화에 담아 주세요. "
            "선택한 괘의 괘사(卦辭)나 효사(爻辭)의 내용을 정확히 인용하며, 현대적 적용 방안도 제시해 주세요. "
            "이야기 마지막에는 선택한 괘와 관련된 '오늘의 명언'을 한글과 영어로 작성해 주세요."
        ),
        "제자백가": (
            "아래 요약 내용을 바탕으로 제자백가 스타일의 1분 30초 분량 대화체 이야기를 만들어 주세요. "
            "중요: 반드시 요약 내용의 핵심 주제, 상황, 문제점, 해결방안을 세밀하게 분석한 후, "
            "그 내용에 가장 적합한 제자백가 철학자를 선정해야 합니다. 임의로 철학자를 선택하지 마세요. "
            "주요 제자백가 철학자: 공자, 맹자, 순자(유교), 노자, 장자, 열자(도교), 묵자(묵가), 한비자, 상앙(법가), 관자(관학), 신불해(술가) 등 "
            "선정 과정: 1) 요약 내용의 핵심 키워드 추출 2) 해당 상황에 맞는 철학 사상 분석 3) 가장 적합한 철학자 선정 4) 선정 이유 간략히 설명 "
            "선택한 철학자의 이름, 사상, 그리고 왜 이 철학자가 요약 내용과 일치하는지 명확히 설명해 주세요. "
            "선택한 철학자와 그의 제자들, 또는 다른 사상가들과의 깊이 있는 대화로 구성해 주세요. "
            "해당 철학자의 핵심 사상과 가르침을 대화에 자연스럽게 담아내고, 현대적 적용 방안도 제시해 주세요. "
            "이야기 마지막에는 선택한 철학자의 사상과 관련된 '오늘의 명언'을 한글과 영어로 작성해 주세요."
        ),
        "피터 드러커, 이나모리 가즈오, 데일 카네기 (기업 및 인재 경영의 대가들)": (
            "아래 요약 내용을 바탕으로 피터 드러커, 이나모리 가즈오, 데일 카네기가 대화하는 1분 30초 분량의 우화를 만들어 주세요. "
            "각 인물의 고유한 경영 철학과 인재 경영, 자기계발, 리더십에 대한 관점을 반영한 생생한 대화로 구성해야 합니다.\n"
            "- 드러커님: 경영의 본질, 목표 설정, 자기관리, 사회적 책임 강조\n"
            "- 이나모리 님: 인생관, 인격경영, 사명감, 인간 존중의 경영 강조\n"
            "- 카네기 님: 인간관계, 동기부여, 긍정적 사고, 실천적 조언 강조\n"
            "중요: 각 인물을 반드시 '드러커님', '이나모리 님', '카네기 님'으로 호칭해 주세요.\n"
            "각자의 관점에서 주제에 대해 대화하며, 서로 다른 접근법으로 경영과 인재 성장의 본질을 탐구하는 과정을 보여주세요. "
            "이야기 마지막에는 '오늘의 명언'으로 요약 내용과 관련된 1줄 명언을 한글과 영어로 작성해 주세요."
        ),
        "마이클 포터, 헨리 민츠버그, 게리 하멜, 클레이튼 크리스텐슨 (경영전략의 대가들)": (
            "아래 요약 내용을 바탕으로 마이클 포터, 헨리 민츠버그, 게리 하멜, 클레이튼 크리스텐슨이 대화하는 1분 30초 분량의 우화를 만들어 주세요. "
            "각 인물의 고유한 전략 이론과 혁신, 경쟁, 변화 관리에 대한 관점을 반영한 생생한 대화로 구성해야 합니다.\n"
            "- 포터님: 경쟁 전략, 산업구조, 차별화와 원가우위\n"
            "- 민츠버그님: 전략의 형성 과정, 조직문화, 실천적 통찰\n"
            "- 하멜 님: 혁신, 미래경영, 경영 패러다임 전환\n"
            "- 크리스텐슨 님: 파괴적 혁신, 기술 변화, 시장 재편\n"
            "중요: 각 인물을 반드시 '포터님', '민츠버그님', '하멜 님', '크리스텐슨 님'으로 호칭해 주세요.\n"
            "각자의 관점에서 주제에 대해 대화하며, 서로 다른 전략적 접근법과 혁신의 본질을 탐구하는 과정을 보여주세요. "
            "이야기 마지막에는 '오늘의 명언'으로 요약 내용과 관련된 1줄 명언을 한글과 영어로 작성해 주세요."
        ),
        "존 폰노이만, 존 내쉬, 토마스 셀링, 애덤 브랜드버거 (게임이론의 대가들)": (
            "아래 요약 내용을 바탕으로 존 폰노이만, 존 내쉬, 토마스 셀링, 애덤 브랜드버거가 대화하는 1분 30초 분량의 우화를 만들어 주세요. "
            "각 인물의 고유한 게임이론, 협상, 전략적 사고, 협력과 경쟁에 대한 관점을 반영한 생생한 대화로 구성해야 합니다.\n"
            "- 폰노이만님: 게임이론의 창시자, 수리적 분석, 전략적 합리성\n"
            "- 내쉬님: 내쉬 균형, 협력과 경쟁의 균형\n"
            "- 셀링님: 협상 이론, 갈등 해결, 신뢰 구축\n"
            "- 브랜드버거님: 협력적 게임, 가치 창출, 파트너십\n"
            "중요: 각 인물을 반드시 '폰노이만님', '내쉬님', '셀링님', '브랜드버거님'으로 호칭해 주세요.\n"
            "각자의 관점에서 주제에 대해 대화하며, 서로 다른 게임이론적 접근법과 전략적 통찰을 탐구하는 과정을 보여주세요. "
            "이야기 마지막에는 '오늘의 명언'으로 요약 내용과 관련된 1줄 명언을 한글과 영어로 작성해 주세요."
        ),
        "제프리 힌튼, 얀 르쿤, 요슈아 벤지오, 앤드류 응 (AI 4대 석학)": (
            "아래 요약 내용을 바탕으로 AI 4대 석학인 제프리 힌튼, 얀 르쿤, 요슈아 벤지오, 앤드류 응이 대화하는 1분 30초 분량의 우화를 만들어 주세요. "
            "각 인물의 고유한 딥러닝 철학, AI 연구 접근 방식, 혁신적 사고를 반영한 생생한 대화로 구성해야 합니다.\n"
            "- 힌튼님: 딥러닝의 창시자, 역전파 알고리즘의 선구자, 노벨 물리학상 수상자, 신경망 기반 AI의 이론적 토대 구축\n"
            "- 르쿤님: 합성곱 신경망(CNN)의 혁신가, Meta 최고 AI 과학자, 컴퓨터 비전 분야의 석학, 현재 AI 기술 한계에 대한 솔직한 평가\n"
            "- 벤지오님: 순환 신경망(RNN)과 딥러닝 발전의 기여자, Turing Award 수상자, AI 안전성과 윤리에 대한 깊은 관심\n"
            "- 응님: Google Brain 창립 멤버, 머신러닝 대중화의 선구자, Coursera를 통한 AI 교육 혁신, 실용적 AI 적용의 전문가\n"
            "중요: 각 인물을 반드시 '힌튼님', '르쿤님', '벤지오님', '응님'으로 호칭해 주세요.\n"
            "각자의 관점에서 주제에 대해 대화하며, 서로 다른 딥러닝 접근법과 AI의 미래, 기술의 사회적 영향에 대한 통찰을 탐구하는 과정을 보여주세요. "
            "이야기 마지막에는 '오늘의 명언'으로 요약 내용과 관련된 1줄 명언을 한글과 영어로 작성해 주세요."
        ),
        "삼국지의 제갈량": (
            "아래 요약 내용을 바탕으로 삼국지의 제갈량이 등장하는 1분 30초 분량 대화체 이야기를 만들어 주세요. "
            "제갈량과 유비, 관우, 장비, 조조, 주유 등 삼국지 등장인물들의 생생한 대화로 구성하고, "
            "제갈량의 뛰어난 지략과 충의, 인재 경영과 전략적 사고를 반영해 주세요. "
            "천하삼분지계, 출사표의 정신, 충성과 의리의 가치를 대화를 통해 전달하고, "
            "현대 비즈니스와 리더십에 적용할 수 있는 지혜를 담아주세요. "
            "이야기 마지막에는 '오늘의 명언'으로 요약 내용과 관련된 1줄 명언을 한글과 영어로 작성해 주세요."
        ),
        "초한지의 장량": (
            "아래 요약 내용을 바탕으로 초한지의 장량(장자방)이 등장하는 1분 30초 분량 대화체 이야기를 만들어 주세요. "
            "장량과 유방(한고조), 소하, 한신, 항우, 범증 등 초한지 등장인물들의 생생한 대화로 구성하고, "
            "장량의 탁월한 모략과 지략, 은인자중의 지혜, 때를 아는 통찰력을 반영해 주세요. "
            "사면초가, 배수진, 명장암도 등의 전략적 사고와 인간관계의 묘수를 대화로 표현하고, "
            "현대의 경영전략과 협상술에 적용할 수 있는 지혜를 담아주세요. "
            "이야기 마지막에는 '오늘의 명언'으로 요약 내용과 관련된 1줄 명언을 한글과 영어로 작성해 주세요."
        ),
        "손자병법의 손무": (
            "아래 요약 내용을 바탕으로 손자병법의 손무가 등장하는 1분 30초 분량 대화체 이야기를 만들어 주세요. "
            "손무와 오자서, 오왕 합려, 손빈 등 손자병법 관련 인물들의 생생한 대화로 구성하고, "
            "손무의 뛰어난 전략과 지혜, 용병술과 리더십, 승리를 위한 통찰력을 반영해 주세요. "
            "지피지기(知彼知己), 군형(軍形), 허실(虛實), 기정(奇正) 등 손자병법의 핵심 원리를 대화로 표현하고, "
            "현대의 경영전략과 리더십에 적용할 수 있는 지혜를 담아주세요. "
            "이야기 마지막에는 '오늘의 명언'으로 요약 내용과 관련된 1줄 명언을 한글과 영어로 작성해 주세요."
        ),
        "주역": (
            "아래 요약 내용을 바탕으로 주역(易經) 스타일의 1분 30초 분량 대화체 이야기를 만들어 주세요. "
            "중요: 반드시 요약 내용을 철저히 분석하여 그 내용과 정확히 일치하는 64괘 중 하나를 선정해야 합니다. 임의로 괘를 선택하지 마세요. 선정한 괘의 철학과 음양의 조화, 변화의 이치를 담은 1분 30초 분량의 깊이 있는 대화체 이야기를 존댓말로 전달하고, 괘 선정 이유와 함께 마지막에 선택한 괘와 관련된 명언을 한글과 영어로 제시합니다."
        ),
        "예수님과 12사도": (
            "제공된 요약 내용의 핵심 주제, 문제점, 해결방안을 철저히 분석한 후, "
            "그 내용을 예수님과 12사도의 스타일로 재해석하여 1분 30초 분량의 대화체 우화를 만들어 주세요. "
            "요약 내용의 상황을 성경 시대의 맥락으로 비유하되, 반드시 원본 요약의 핵심 메시지와 교훈을 유지해야 합니다. "
            "예수님의 가르침 방식을 따라 비유와 실제 삶의 예시를 통해 요약 내용의 핵심을 영적, 도덕적 교훈으로 전달하는 형식으로 작성해 주세요. "
            "예수님과 12사도들(베드로, 요한, 야고보, 안드레, 빌립, 바돌로매, 마태, 도마, 알패오의 아들 야고보, 다대오, 시몬, 유다)이 요약 내용의 문제를 성경 시대의 관점에서 논의하고 해결책을 찾는 형식으로 구성하고, "
            "스승과 제자의 관계를 중심으로, 사랑, 용서, 겸손, 섬김의 가치를 반영하여 따뜻하고 감동적인 대화로 구성해 주세요. "
            "성경의 언어와 분위기를 자연스럽게 살리고, 제자들의 다양한 성격과 관점이 드러나도록 해주세요. "
            "중요: 성경의 일반 이야기가 아닌, 요약 내용을 예수님과 12사도 스타일로 표현한 우화를 만들어야 합니다. "
            "대화에서 예수님을 지칭할 때는 반드시 '예수님:'으로 표시해 주세요. (예: '예수:' 가 아닌 '예수님:' 으로) "
            "이야기 마지막에는 '오늘의 명언'으로 요약 내용과 관련된 1줄 명언을 한글과 영어로 작성해 주세요."
        ),
    }
    
    fable_instruction = fable_instructions.get(fable_type, fable_instructions["이솝우화"])
    
    if model_name.startswith('claude'):
        # 하모니아 선택시 토큰 수를 2배로 설정
        max_tokens = 5000 if fable_type == "하모니아" else 2500
        client = ChatAnthropic(model=model_name, api_key=os.getenv('ANTHROPIC_API_KEY'), temperature=0.7, max_tokens=max_tokens)
        
        # extra_prompt가 있으면 그것을 우선적으로 반영
        if extra_prompt and extra_prompt.strip():
            prompt = f"""
{fable_instruction}

[중요: 아래 추가 요청사항을 반드시 우선적으로 반영해 주세요]
{extra_prompt.strip()}

---
{text}
"""
        else:
            prompt = f"""
{fable_instruction}
---
{text}
"""
        # 각 우화 스타일별 시스템 프롬프트
        system_prompts = {
            "하모니아": (
                "당신은 동서양의 위대한 사상가들의 대화를 구성하는 전문가입니다. "
                "다음 각 그룹에서 랜덤하게 1명씩 선택하여 3분 분량의 심오하고 통찰력 있는 대화를 구성합니다:\n"
                "1. 4대 성인 중 1명 (예수님, 부처님, 공자님, 소크라테스님)\n"
                "2. 중국 고대 사상가 중 1명 (장자님, 노자님, 맹자님, 순자님, 묵자님, 한비자님, 공손룡님)\n"
                "3. 동양의 전략가 중 1명 (제갈량님, 장량님, 손무님)\n"
                "4. 기업 및 인재 경영의 대가 중 1명 (피터 드러커님, 이나모리 가즈오님, 데일 카네기님)\n"
                "5. 경영전략의 대가 중 1명 (마이클 포터님, 헨리 민츠버그님, 게리 하멜님, 클레이튼 크리스텐슨님)\n"
                "6. 게임이론의 대가 중 1명 (존 폰노이만님, 존 내쉬님, 토마스 셀링님, 애덤 브랜드버거님)\n"
                "각 인물의 고유한 철학과 사상을 정확히 반영하여 존댓말로 대화를 구성하고, "
                "서로를 반드시 '님'을 붙여 호칭하며(예: '공자님', '드러커님'), "
                "대화 시작 시 '참석자: [선택된 인물] ([분야])' 형태로 간략하게 소개해 주세요. "
                "예: '참석자: 예수님 (4대 성인), 맹자님 (동양 사상가), 제갈량님 (고대 전략가), 이나모리 가즈오님 (회사/인간 경영의 대가), 마이클 포터님 (경영 전략가), 존 내쉬님 (게임이론가)'\n"
                "각 인물의 주요 사상과 특징을 반영하여 대화를 구성해 주세요.\n"
                "대화가 끝난 후, 요약 내용의 핵심 주제와 관련된 '오늘의 명언'을 한글과 영어로 제시해 주세요.\n"
                "- 맹자님: 성선설, 왕도정치\n"
                "- 순자님: 성악설, 예치주의\n"
                "- 묵자님: 겸애(兼愛)와 비공(非攻)\n"
                "- 한비자님: 법가사상, 법치주의\n"
                "- 공손룡님: 명가(名家), 논리철학\n"
                "매번 새로운 대화를 생성할 때마다 각 그룹에서 다른 인물을 선택하여 다양한 조합의 대화가 만들어지도록 해주세요."
            ),
            "예수님과 12사도": "당신은 요약 내용을 정확히 분석하여 예수님과 12사도 스타일의 우화로 재해석하는 전문가입니다. 반드시 제공된 요약의 핵심 메시지와 교훈을 유지한 채, 예수님의 가르침 방식과 12사도들의 다양한 성격을 통해 1분 30초 분량의 성경 시대 맥락의 생생한 대화체 이야기를 존댓말로 전달하고, 마지막에 명언을 한글과 영어로 제시합니다.",
            "이솝우화": "당신은 이솝우화 전문 스토리텔러입니다. 동물들이 주인공인 1분 30초 분량의 생생한 대화체 우화를 만들어 존댓말로 전달하고, 마지막에 명언을 한글과 영어로 제시합니다.",
            "탈무드": "당신은 탈무드 지혜 전달자입니다. 랍비와 제자들의 생생한 대화를 통해 1분 30초 분량의 실용적이고 철학적인 교훈을 존댓말로 전달하고, 마지막에 명언을 한글과 영어로 제시합니다.",
            "성경이야기": "당신은 성경 비유 이야기 전문가입니다. 사랑, 용서, 겸손의 가치를 담은 1분 30초 분량의 감동적인 대화체 비유를 존댓말로 전달하고, 마지막에 명언을 한글과 영어로 제시합니다.",
            "4대 성인 대화(예수님, 부처님, 공자님, 소크라테스님)": "당신은 4대 성인의 사상을 정확히 아는 철학 대화 전문가입니다. 각 성인의 고유한 철학과 가르침을 반영한 1분 30초 분량의 생생한 대화를 존댓말로 구성하고, 서로를 호칭할 때는 반드시 '소크라테스님', '공자님', '예수님', '부처님'을 사용하며, 마지막에 명언을 한글과 영어로 제시합니다.",
            "장자 이야기": "당신은 장자 철학 전문가입니다. 무위자연과 상대성, 자유로운 정신을 담은 1분 30초 분량의 기발하고 역설적인 대화체 우화를 존댓말로 전달하고, 마지막에 명언을 한글과 영어로 제시합니다.",
            "노자의 도덕경": "당신은 노자 도덕경 전문가입니다. 도(道), 무위(無爲), 음양의 조화와 겸손함을 담은 1분 30초 분량의 깊이 있는 대화체 이야기를 존댓말로 전달하고, 마지막에 명언을 한글과 영어로 제시합니다.",
            "삼국지의 제갈량": "당신은 요약 내용을 정확히 분석하여 삼국지 제갈량 스타일의 우화로 재해석하는 전문가입니다. 반드시 제공된 요약의 핵심 메시지와 교훈을 유지한 채, 제갈량의 지략과 충의를 통해 1분 30초 분량의 삼국지 등장인물들 간의 생생한 대화체 이야기를 존댓말로 전달하고, 마지막에 명언을 한글과 영어로 제시합니다.",
            "초한지의 장량": "당신은 요약 내용을 정확히 분석하여 초한지 장량 스타일의 우화로 재해석하는 전문가입니다. 반드시 제공된 요약의 핵심 메시지와 교훈을 유지한 채, 장량의 모략과 지략, 은인자중의 지혜를 통해 1분 30초 분량의 초한지 등장인물들 간의 생생한 대화체 이야기를 존댓말로 전달하고, 마지막에 명언을 한글과 영어로 제시합니다.",
            "손자병법의 손무": "당신은 손자병법 전문가입니다. 손무의 전략과 지혜, 용병술과 리더십을 담은 1분 30초 분량의 생생한 대화체 이야기를 존댓말로 전달하고, 마지막에 명언을 한글과 영어로 제시합니다.",
            "주역": "당신은 주역(易經) 전문가입니다. 반드시 요약 내용을 철저히 분석하여 그 내용과 정확히 일치하는 64괘 중 하나를 선정해야 합니다. 임의로 괘를 선택하지 마세요. 선정한 괘의 철학과 음양의 조화, 변화의 이치를 담은 1분 30초 분량의 깊이 있는 대화체 이야기를 존댓말로 전달하고, 괘 선정 이유와 함께 마지막에 선택한 괘와 관련된 명언을 한글과 영어로 제시합니다.",
            "제자백가": "당신은 제자백가 전문가입니다. 반드시 요약 내용을 철저히 분석하여 그 내용에 가장 적합한 제자백가 철학자(공자, 맹자, 순자, 노자, 장자, 묵자, 한비자, 관자 등)를 선정해야 합니다. 임의로 철학자를 선택하지 마세요. 선정한 철학자의 사상과 가르침을 담은 1분 30초 분량의 깊이 있는 대화체 이야기를 존댓말로 전달하고, 철학자 선정 이유와 함께 마지막에 선택한 철학자와 관련된 명언을 한글과 영어로 제시합니다.",
            "피터 드러커, 이나모리 가즈오, 데일 카네기 (기업 및 인재 경영의 대가들)": "당신은 피터 드러커, 이나모리 가즈오, 데일 카네기의 경영 철학과 인재 경영, 자기계발, 리더십에 정통한 전문가입니다. 각 인물의 고유한 관점과 사상을 반영한 1분 30초 분량의 생생한 대화체 우화를 존댓말로 구성하고, 서로를 반드시 '드러커님', '이나모리 님', '카네기 님'으로 호칭하며, 마지막에 명언을 한글과 영어로 제시합니다.",
            "마이클 포터, 헨리 민츠버그, 게리 하멜, 클레이튼 크리스텐슨 (경영전략의 대가들)": "당신은 마이클 포터, 헨리 민츠버그, 게리 하멜, 클레이튼 크리스텐슨의 전략 이론과 혁신, 경쟁, 변화 관리에 정통한 전문가입니다. 각 인물의 고유한 전략적 관점과 사상을 반영한 1분 30초 분량의 생생한 대화체 우화를 존댓말로 구성하고, 서로를 반드시 '포터님', '민츠버그님', '하멜 님', '크리스텐슨 님'으로 호칭해 주세요.\n",
            "제프리 힌튼, 얀 르쿤, 요슈아 벤지오, 앤드류 응 (AI 4대 석학)": "당신은 AI 4대 석학인 제프리 힌튼, 얀 르쿤, 요슈아 벤지오, 앤드류 응의 딥러닝 철학과 AI 연구 접근 방식, 혁신적 사고에 정통한 전문가입니다. 각 인물의 고유한 딥러닝 관점과 기술 철학을 반영한 1분 30초 분량의 생생한 대화체 우화를 존댓말로 구성하고, 서로를 반드시 '힌튼님', '르쿤님', '벤지오님', '응님'으로 호칭하며, 마지막에 명언을 한글과 영어로 제시합니다."
        }
        
        system_prompt = system_prompts.get(fable_type, system_prompts["이솝우화"])
        
        # extra_prompt가 있을 때는 시스템 프롬프트에 추가 지시 포함
        if extra_prompt and extra_prompt.strip():
            system_prompt += " 사용자의 추가 요청사항이 있을 경우 기본 스타일보다 사용자 요청을 우선적으로 반영하여 창작해 주세요."
        
        response = client.invoke([
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": prompt}
        ])
        return response.content if hasattr(response, 'content') else str(response)
    else:
        # OpenAI API 키 검증
        openai_key = os.getenv('OPENAI_API_KEY')
        if not openai_key or openai_key.strip() == '' or openai_key == 'NA':
            raise ValueError(f"OpenAI API 키가 올바르지 않습니다. 현재 값: {openai_key}")
        
        try:
            client = OpenAI(api_key=openai_key)
            
            # extra_prompt가 있으면 그것을 우선적으로 반영
            if extra_prompt and extra_prompt.strip():
                prompt = f"""
{fable_instruction}

[중요: 아래 추가 요청사항을 반드시 우선적으로 반영해 주세요]
{extra_prompt.strip()}

---
{text}
"""
            else:
                prompt = f"""
{fable_instruction}
---
{text}
"""
            # 각 우화 스타일별 시스템 프롬프트
            system_prompts = {
                "예수님과 12사도": "당신은 요약 내용을 정확히 분석하여 예수님과 12사도 스타일의 우화로 재해석하는 전문가입니다. 반드시 제공된 요약의 핵심 메시지와 교훈을 유지한 채, 예수님의 가르침 방식과 12사도들의 다양한 성격을 통해 1분 30초 분량의 성경 시대 맥락의 생생한 대화체 이야기를 존댓말로 전달하고, 마지막에 명언을 한글과 영어로 제시합니다.",
                "하모니아": (
                    "당신은 동서양의 위대한 사상가들의 대화를 구성하는 전문가입니다. "
                    "다음 각 그룹에서 랜덤하게 1명씩 선택하여 3분 분량의 심오하고 통찰력 있는 대화를 구성합니다:\n"
                    "1. 4대 성인 중 1명 (예수님, 부처님, 공자님, 소크라테스님)\n"
                    "2. 중국 고대 사상가 중 1명 (장자님, 노자님, 맹자님, 순자님, 묵자님, 한비자님, 공손룡님)\n"
                    "3. 동양의 전략가 중 1명 (제갈량님, 장량님, 손무님)\n"
                    "4. 기업 및 인재 경영의 대가 중 1명 (피터 드러커님, 이나모리 가즈오님, 데일 카네기님)\n"
                    "5. 경영전략의 대가 중 1명 (마이클 포터님, 헨리 민츠버그님, 게리 하멜님, 클레이튼 크리스텐슨님)\n"
                    "6. 게임이론의 대가 중 1명 (존 폰노이만님, 존 내쉬님, 토마스 셀링님, 애덤 브랜드버거님)\n"
                    "7. AI 4대 석학 중 1명 (제프리 힌튼님, 얀 르쿤님, 요슈아 벤지오님, 앤드류 응님)\n"
                    "각 인물의 고유한 철학과 사상을 정확히 반영하여 존댓말로 대화를 구성하고, "
                    "서로를 반드시 '님'을 붙여 호칭하며(예: '공자님', '드러커님', '힌튼님'), "
                    "대화 시작 시 '참석자: [선택된 인물] ([분야])' 형태로 간략하게 소개해 주세요. "
                    "예: '참석자: 예수님 (4대 성인), 맹자님 (동양 사상가), 제갈량님 (고대 전략가), 이나모리 가즈오님 (회사/인간 경영의 대가), 마이클 포터님 (경영 전략가), 존 내쉬님 (게임이론가), 제프리 힌튼님 (AI 석학)'\n"
                    "각 인물의 주요 사상과 특징을 반영하여 대화를 구성해 주세요.\n"
                    "대화가 끝난 후, 요약 내용의 핵심 주제와 관련된 '오늘의 명언'을 한글과 영어로 제시해 주세요."),
                "이솝우화": "당신은 이솝우화 전문 스토리텔러입니다. 동물들이 주인공인 1분 30초 분량의 생생한 대화체 우화를 만들어 존댓말로 전달하고, 마지막에 명언을 한글과 영어로 제시합니다.",
                "탈무드": "당신은 탈무드 지혜 전달자입니다. 랍비와 제자들의 생생한 대화를 통해 1분 30초 분량의 실용적이고 철학적인 교훈을 존댓말로 전달하고, 마지막에 명언을 한글과 영어로 제시합니다.",
                "성경이야기": "당신은 성경 비유 이야기 전문가입니다. 사랑, 용서, 겸손의 가치를 담은 1분 30초 분량의 감동적인 대화체 비유를 존댓말로 전달하고, 마지막에 명언을 한글과 영어로 제시합니다.",
                "4대 성인 대화(예수님, 부처님, 공자님, 소크라테스님)": "당신은 4대 성인의 사상을 정확히 아는 철학 대화 전문가입니다. 각 성인의 고유한 철학과 가르침을 반영한 1분 30초 분량의 생생한 대화를 존댓말로 구성하고, 서로를 호칭할 때는 반드시 '소크라테스님', '공자님', '예수님', '부처님'을 사용하며, 마지막에 명언을 한글과 영어로 제시합니다.",
                "장자 이야기": "당신은 장자 철학 전문가입니다. 무위자연과 상대성, 자유로운 정신을 담은 1분 30초 분량의 기발하고 역설적인 대화체 우화를 존댓말로 전달하고, 마지막에 명언을 한글과 영어로 제시합니다.",
                "노자의 도덕경": "당신은 노자 도덕경 전문가입니다. 도(道), 무위(無爲), 음양의 조화와 겸손함을 담은 1분 30초 분량의 깊이 있는 대화체 이야기를 존댓말로 전달하고, 마지막에 명언을 한글과 영어로 제시합니다.",
                "삼국지의 제갈량": "당신은 요약 내용을 정확히 분석하여 삼국지 제갈량 스타일의 우화로 재해석하는 전문가입니다. 반드시 제공된 요약의 핵심 메시지와 교훈을 유지한 채, 제갈량의 지략과 충의를 통해 1분 30초 분량의 삼국지 등장인물들 간의 생생한 대화체 이야기를 존댓말로 전달하고, 마지막에 명언을 한글과 영어로 제시합니다.",
                "초한지의 장량": "당신은 요약 내용을 정확히 분석하여 초한지 장량 스타일의 우화로 재해석하는 전문가입니다. 반드시 제공된 요약의 핵심 메시지와 교훈을 유지한 채, 장량의 모략과 지략, 은인자중의 지혜를 통해 1분 30초 분량의 초한지 등장인물들 간의 생생한 대화체 이야기를 존댓말로 전달하고, 마지막에 명언을 한글과 영어로 제시합니다.",
                "손자병법의 손무": "당신은 손자병법 전문가입니다. 손무의 전략과 지혜, 용병술과 리더십을 담은 1분 30초 분량의 생생한 대화체 이야기를 존댓말로 전달하고, 마지막에 명언을 한글과 영어로 제시합니다.",
                "주역": "당신은 주역(易經) 전문가입니다. 반드시 요약 내용을 철저히 분석하여 그 내용과 정확히 일치하는 64괘 중 하나를 선정해야 합니다. 임의로 괘를 선택하지 마세요. 선정한 괘의 철학과 음양의 조화, 변화의 이치를 담은 1분 30초 분량의 깊이 있는 대화체 이야기를 존댓말로 전달하고, 괘 선정 이유와 함께 마지막에 선택한 괘와 관련된 명언을 한글과 영어로 제시합니다.",
                "제자백가": "당신은 제자백가 전문가입니다. 반드시 요약 내용을 철저히 분석하여 그 내용에 가장 적합한 제자백가 철학자(공자, 맹자, 순자, 노자, 장자, 묵자, 한비자, 관자 등)를 선정해야 합니다. 임의로 철학자를 선택하지 마세요. 선정한 철학자의 사상과 가르침을 담은 1분 30초 분량의 깊이 있는 대화체 이야기를 존댓말로 전달하고, 철학자 선정 이유와 함께 마지막에 선택한 철학자와 관련된 명언을 한글과 영어로 제시합니다.",
                "피터 드러커, 이나모리 가즈오, 데일 카네기 (기업 및 인재 경영의 대가들)": "당신은 피터 드러커, 이나모리 가즈오, 데일 카네기의 경영 철학과 인재 경영, 자기계발, 리더십에 정통한 전문가입니다. 각 인물의 고유한 관점과 사상을 반영한 1분 30초 분량의 생생한 대화체 우화를 존댓말로 구성하고, 서로를 반드시 '드러커님', '이나모리 님', '카네기 님'으로 호칭하며, 마지막에 명언을 한글과 영어로 제시합니다.",
                "마이클 포터, 헨리 민츠버그, 게리 하멜, 클레이튼 크리스텐슨 (경영전략의 대가들)": "당신은 마이클 포터, 헨리 민츠버그, 게리 하멜, 클레이튼 크리스텐슨의 전략 이론과 혁신, 경쟁, 변화 관리에 정통한 전문가입니다. 각 인물의 고유한 전략적 관점과 사상을 반영한 1분 30초 분량의 생생한 대화체 우화를 존댓말로 구성하고, 서로를 반드시 '포터님', '민츠버그님', '하멜 님', '크리스텐슨 님'으로 호칭해 주세요.\n",
                "제프리 힌튼, 얀 르쿤, 요슈아 벤지오, 앤드류 응 (AI 4대 석학)": "당신은 AI 4대 석학인 제프리 힌튼, 얀 르쿤, 요슈아 벤지오, 앤드류 응의 딥러닝 철학과 AI 연구 접근 방식, 혁신적 사고에 정통한 전문가입니다. 각 인물의 고유한 딥러닝 관점과 기술 철학을 반영한 1분 30초 분량의 생생한 대화체 우화를 존댓말로 구성하고, 서로를 반드시 '힌튼님', '르쿤님', '벤지오님', '응님'으로 호칭하며, 마지막에 명언을 한글과 영어로 제시합니다."
            }
            
            system_prompt = system_prompts.get(fable_type, system_prompts["이솝우화"])
            
            # extra_prompt가 있을 때는 시스템 프롬프트에 추가 지시 포함
            if extra_prompt and extra_prompt.strip():
                system_prompt += " 사용자의 추가 요청사항이 있을 경우 기본 스타일보다 사용자 요청을 우선적으로 반영하여 창작해 주세요."
            
            response = client.chat.completions.create(
                model=model_name,
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": prompt}
                ],
                max_tokens=2500,
                temperature=0.7
            )
            return response.choices[0].message.content
        except Exception as e:
            st.error(f"OpenAI API 호출 중 오류: {str(e)}")
            st.error(f"API 키 상태: {openai_key[:10] if openai_key else 'None'}... (길이: {len(openai_key) if openai_key else 0})")
            raise e

# 요약 함수 (Claude/OpenAI 모두 지원)
def ai_summarize(text, model_name, extra_prompt=None):
    summary_instruction = (
        "아래 텍스트를 700자 이내로 요약해 주세요. "
        "소제목 3~4개와 각 소제목당 2~3개의 bullet point로 구성해 주세요. "
        "각 항목은 '~함' 형태의 간결한 한글로 작성하고, 존댓말은 사용하지 마세요. "
        "[중요] 글자 수 제한이 있지만 내용의 품질과 완성도가 최우선입니다. "
        "원본 텍스트의 핵심 개념, 주요 인사이트, 실무 적용점을 빠짐없이 포함해야 합니다. "
        "단순히 글자 수를 맞추기 위해 중요한 내용을 생략하거나 부실하게 작성하지 마세요. "
        "각 bullet point는 구체적이고 실질적인 내용을 담아야 하며, 추상적이거나 모호한 표현은 피하세요. "
        "핵심 내용을 압축하여 표현하되, 의미가 손실되지 않도록 주의해 주세요. "
        "[최적화] 각 bullet point는 40~50자 내외로 핵심을 충실하게 작성하고, 불필요한 설명은 제거해 주세요. "
        "[출력 형식] 제목은 **제목** 형태로, bullet point는 • 로 시작하도록 작성해 주세요. "
        "[구조] 소제목 → bullet 2~3개 → 소제목 → bullet 2~3개 순서로 작성해 주세요."
    )
    if model_name.startswith('claude'):
        client = ChatAnthropic(model=model_name, api_key=os.getenv('ANTHROPIC_API_KEY'), temperature=0.3, max_tokens=4000)
        prompt = f"""
{summary_instruction}
---
{text}
"""
        if extra_prompt and extra_prompt.strip():
            prompt += f"\n[참고 내용]\n{extra_prompt.strip()}\n"
        response = client.invoke([
            {"role": "system", "content": "당신은 요약 전문가입니다. 항상 700자 이내로 요약하며, 소제목 3~4개와 각 소제목당 2~3개의 bullet point로 구성합니다. 주제별 제목과 함께 '~함' 형태의 간결체로 작성합니다. 존댓말은 사용하지 않습니다. [중요] 글자 수 제한보다 내용의 품질과 완성도가 최우선입니다. 원본의 핵심 개념, 인사이트, 실무 적용점을 빠짐없이 포함하고, 구체적이고 실질적인 내용으로 작성해야 합니다. 핵심 내용을 압축하여 표현하되, 의미가 손실되지 않도록 주의합니다. [최적화] 각 bullet point는 40~50자 내외로 핵심을 충실하게 작성하고, 불필요한 설명은 제거합니다. [출력 형식] 제목은 **제목** 형태로, bullet point는 • 로 시작하도록 작성합니다. [구조] 소제목 → bullet 2~3개 → 소제목 → bullet 2~3개 순서로 작성합니다."},
            {"role": "user", "content": prompt}
        ])
        return response.content if hasattr(response, 'content') else str(response)
    else:
        # OpenAI API 키 검증
        openai_key = os.getenv('OPENAI_API_KEY')
        if not openai_key or openai_key.strip() == '' or openai_key == 'NA':
            raise ValueError(f"OpenAI API 키가 올바르지 않습니다. 현재 값: {openai_key}")
        
        try:
            client = OpenAI(api_key=openai_key)
            prompt = f"""
{summary_instruction}
---
{text}
"""
            if extra_prompt and extra_prompt.strip():
                prompt += f"\n[참고 내용]\n{extra_prompt.strip()}\n"
            response = client.chat.completions.create(
                model=model_name,
                messages=[
                    {"role": "system", "content": "당신은 요약 전문가입니다. 항상 700자 이내로 요약하며, 소제목 3~4개와 각 소제목당 2~3개의 bullet point로 구성합니다. 주제별 제목과 함께 '~함' 형태의 간결체로 작성합니다. 존댓말은 사용하지 않습니다. [중요] 글자 수 제한보다 내용의 품질과 완성도가 최우선입니다. 원본의 핵심 개념, 인사이트, 실무 적용점을 빠짐없이 포함하고, 구체적이고 실질적인 내용으로 작성해야 합니다. 핵심 내용을 압축하여 표현하되, 의미가 손실되지 않도록 주의합니다. [최적화] 각 bullet point는 40~50자 내외로 핵심을 충실하게 작성하고, 불필요한 설명은 제거합니다. [출력 형식] 제목은 **제목** 형태로, bullet point는 • 로 시작하도록 작성합니다. [구조] 소제목 → bullet 2~3개 → 소제목 → bullet 2~3개 순서로 작성합니다."},
                    {"role": "user", "content": prompt}
                ],
                max_tokens=4000,
                temperature=0.3
            )
            return response.choices[0].message.content
        except Exception as e:
            st.error(f"OpenAI API 호출 중 오류: {str(e)}")
            st.error(f"API 키 상태: {openai_key[:10] if openai_key else 'None'}... (길이: {len(openai_key) if openai_key else 0})")
            raise e

# 적용 파일 생성 함수 (Claude/OpenAI 모두 지원)
def ai_generate_application(summary_text, application_text, model_name, extra_prompt=None):
    if model_name.startswith('claude'):
        client = ChatAnthropic(model=model_name, api_key=os.getenv('ANTHROPIC_API_KEY'), temperature=0.3, max_tokens=8192)
        prompt = f"""
아래의 '요약 내용'과 '기존 적용 파일'을 참고하여, 기존 적용 파일을 개선/보완한 새로운 적용 파일을 작성해 주세요.\n\n[절대적 요구사항]\n- 기존 적용 파일의 대부분의 핵심 내용이 빠짐없이 포함되어야 합니다. 중요한 내용이 누락되지 않도록 하세요.\n- 기존 적용 파일의 모든 섹션, 소제목, 구조를 그대로 유지하세요.\n- 요약 내용의 핵심 인사이트와 지침을 반드시 반영해 주세요.\n- 기존 적용 파일의 구조와 맥락을 최대한 유지하되, 중복은 피하고 자연스럽게 통합해 주세요.\n- 반드시 존댓말을 사용해 주세요.\n\n[요약 내용]\n{summary_text}\n\n[기존 적용 파일]\n{application_text}\n"""
        if extra_prompt and extra_prompt.strip():
            prompt += f"\n[참고 내용]\n{extra_prompt.strip()}\n"
        response = client.invoke([
            {"role": "system", "content": "당신은 적용 파일 통합 전문가입니다. 반드시 기존 적용 파일의 대부분의 핵심 내용이 빠짐없이 포함되고, 구조와 맥락을 유지하며, 존댓말로 작성합니다. 중요한 내용 누락 금지."},
            {"role": "user", "content": prompt}
        ])
        return response.content if hasattr(response, 'content') else str(response)
    else:
        # OpenAI API 키 검증
        openai_key = os.getenv('OPENAI_API_KEY')
        if not openai_key or openai_key.strip() == '' or openai_key == 'NA':
            raise ValueError(f"OpenAI API 키가 올바르지 않습니다. 현재 값: {openai_key}")
        
        try:
            client = OpenAI(api_key=openai_key)
            prompt = f"""
아래의 '요약 내용'과 '기존 적용 파일'을 참고하여, 기존 적용 파일을 개선/보완한 새로운 적용 파일을 작성해 주세요.\n\n[절대적 요구사항]\n- 기존 적용 파일의 대부분의 핵심 내용이 빠짐없이 포함되어야 합니다. 중요한 내용이 누락되지 않도록 하세요.\n- 기존 적용 파일의 모든 섹션, 소제목, 구조를 그대로 유지하세요.\n- 요약 내용의 핵심 인사이트와 지침을 반드시 반영해 주세요.\n- 기존 적용 파일의 구조와 맥락을 최대한 유지하되, 중복은 피하고 자연스럽게 통합해 주세요.\n- 반드시 존댓말을 사용해 주세요.\n\n[요약 내용]\n{summary_text}\n\n[기존 적용 파일]\n{application_text}\n"""
            if extra_prompt and extra_prompt.strip():
                prompt += f"\n[참고 내용]\n{extra_prompt.strip()}\n"
            response = client.chat.completions.create(
                model=model_name,
                messages=[
                    {"role": "system", "content": "당신은 적용 파일 통합 전문가입니다. 반드시 기존 적용 파일의 대부분의 핵심 내용이 빠짐없이 포함되고, 구조와 맥락을 유지하며, 존댓말로 작성합니다. 중요한 내용 누락 금지."},
                    {"role": "user", "content": prompt}
                ],
                max_tokens=8192,
                temperature=0.3
            )
            return response.choices[0].message.content
        except Exception as e:
            st.error(f"OpenAI API 호출 중 오류: {str(e)}")
            st.error(f"API 키 상태: {openai_key[:10] if openai_key else 'None'}... (길이: {len(openai_key) if openai_key else 0})")
            raise e

def summarize_for_tts(text, max_length=3500):
    if len(text) <= max_length:
        return text
    lines = text.split('\n')
    summary = []
    current_length = 0
    for line in lines:
        if line.startswith('#') or line.startswith('##'):
            if current_length + len(line) + 2 <= max_length:
                summary.append(line)
                current_length += len(line) + 2
        elif '[핵심 요약]' in line or '[주요 분석]' in line or '[실행 제안]' in line:
            if current_length + len(line) + 2 <= max_length:
                summary.append(line)
                current_length += len(line) + 2
    return '\n'.join(summary)

def text_to_speech(text, speed=1.2):
    try:
        # OpenAI API 키 검증
        openai_key = os.getenv('OPENAI_API_KEY')
        if not openai_key or openai_key.strip() == '' or openai_key == 'NA':
            st.error(f"OpenAI API 키가 올바르지 않습니다. 현재 값: {openai_key}")
            return None
            
        client = OpenAI(api_key=openai_key)
        response = client.audio.speech.create(
            model="tts-1",
            voice="alloy",
            input=text,
            speed=speed
        )
        audio_data = response.content
        audio_base64 = base64.b64encode(audio_data).decode('utf-8')
        audio_html = f'''
            <audio controls>
                <source src="data:audio/mp3;base64,{audio_base64}" type="audio/mp3">
                Your browser does not support the audio element.
            </audio>
        '''
        return audio_html
    except Exception as e:
        st.error(f"음성 변환 중 오류 발생: {str(e)}")
        if 'openai_key' in locals():
            st.error(f"API 키 상태: {openai_key[:10] if openai_key else 'None'}... (길이: {len(openai_key) if openai_key else 0})")
        return None

def text_to_speech_fable(text, fable_type):
    """우화용 다중 화자 음성 생성 함수"""
    try:
        # OpenAI API 키 검증
        openai_key = os.getenv('OPENAI_API_KEY')
        if not openai_key or openai_key.strip() == '' or openai_key == 'NA':
            st.error(f"OpenAI API 키가 올바르지 않습니다. 현재 값: {openai_key}")
            return None
            
        client = OpenAI(api_key=openai_key)
        
        # 우화 스타일별 voice 및 속도 설정
        voice_settings = {
            "예수님과 12사도": {"voice": "onyx", "speed": 1.2},  # 경건하고 깊이 있는 목소리
            "이솝우화": {"voice": "nova", "speed": 1.2},  # 활발한 동물 캐릭터
            "탈무드": {"voice": "echo", "speed": 1.2},   # 지혜로운 랍비
            "성경이야기": {"voice": "shimmer", "speed": 1.2},  # 따뜻한 성경 이야기
            "4대 성인 대화(예수님, 부처님, 공자님, 소크라테스님)": {"voice": "onyx", "speed": 1.2},  # 거룩하고 깊이 있는 목소리
            "장자 이야기": {"voice": "alloy", "speed": 1.2},  # 신비로운 철학자
            "노자의 도덕경": {"voice": "onyx", "speed": 1.2},  # 깊이 있고 거룩한 목소리
            "삼국지의 제갈량": {"voice": "echo", "speed": 1.2},  # 지략가의 차분한 목소리
            "초한지의 장량": {"voice": "alloy", "speed": 1.2},  # 모략가의 신중한 목소리
            "주역": {"voice": "onyx", "speed": 1.2},  # 깊이 있고 신비로운 주역 현자의 목소리
            "제자백가": {"voice": "echo", "speed": 1.2},  # 철학자들의 깊이 있고 지혜로운 목소리",
            "피터 드러커, 이나모리 가즈오, 데일 카네기 (기업 및 인재 경영의 대가들)": {"voice": "echo", "speed": 1.2},
            "마이클 포터, 헨리 민츠버그, 게리 하멜, 클레이튼 크리스텐슨 (경영전략의 대가들)": {"voice": "onyx", "speed": 1.2},
            "존 폰노이만, 존 내쉬, 토마스 셀링, 애덤 브랜드버거 (게임이론의 대가들)": {"voice": "alloy", "speed": 1.2},
            "제프리 힌튼, 얀 르쿤, 요슈아 벤지오, 앤드류 응 (AI 4대 석학)": {"voice": "echo", "speed": 1.2}  # 논리적이고 지적인 딥러닝 석학들의 목소리
        }
        
        # 기본값 설정
        setting = voice_settings.get(fable_type, {"voice": "alloy", "speed": 1.2})
        
        response = client.audio.speech.create(
            model="tts-1",
            voice=setting["voice"],
            input=text,
            speed=setting["speed"]
        )
        audio_data = response.content
        audio_base64 = base64.b64encode(audio_data).decode('utf-8')
        audio_html = f'''
            <audio controls>
                <source src="data:audio/mp3;base64,{audio_base64}" type="audio/mp3">
                Your browser does not support the audio element.
            </audio>
        '''
        return audio_html
    except Exception as e:
        st.error(f"우화 음성 변환 중 오류 발생: {str(e)}")
        if 'openai_key' in locals():
            st.error(f"API 키 상태: {openai_key[:10] if openai_key else 'None'}... (길이: {len(openai_key) if openai_key else 0})")
        return None

# --- JS 동적 효과 함수 추가 (스코프 적용) ---
def get_alarm_js_scoped():
    return """
    <script>
    let audioContext = null;
    let isAudioInitialized = false;
    async function initAudioContext() {
        if (!isAudioInitialized) {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                await audioContext.resume();
                isAudioInitialized = true;
            } catch (e) { console.error('오디오 컨텍스트 초기화 실패:', e); }
        }
    }
    async function playBeep() {
        await initAudioContext();
        if (!audioContext) return;
        try {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.5);
        } catch (e) { console.error('비프음 재생 실패:', e); }
    }
    window.playBeep = playBeep;
    </script>
    """
def get_toast_notification_js_scoped():
    return """
    <style>
    .order-tab-root .toast { visibility: hidden; min-width: 250px; margin-left: -125px; background-color: #ff4b4b; color: white; text-align: center; border-radius: 10px; padding: 16px; position: fixed; z-index: 1000; left: 50%; bottom: 30px; font-size: 18px; font-weight: bold; box-shadow: 0px 0px 10px rgba(0,0,0,0.5); transition: visibility 0.5s, opacity 0.5s; opacity: 0; }
    .order-tab-root .toast.show { visibility: visible; opacity: 1; }
    </style>
    <div class="toast"></div>
    <script>
    function showToast(message) {
        const toast = document.querySelector('.order-tab-root .toast');
        if (!toast) return;
        toast.textContent = message;
        toast.className = "toast show";
        setTimeout(() => { toast.className = toast.className.replace("show", ""); }, 3000);
    }
    window.showToast = showToast;
    </script>
    """

def get_obsidian_notification_js_scoped():
    return '''
    <div class="obsidian-alert" style="display: none;">
        <div class="alert-content">
            <div class="large-emoji">🎙️</div>
            <div class="alert-text">Tiro 녹음기능을 활성화해 주세요!</div>
        </div>
    </div>
    <script>
    function showObsidianNotification() {
        const alert = document.querySelector('.order-tab-root .obsidian-alert');
        if (!alert) return;
        alert.style.display = 'flex';
        setTimeout(() => { alert.style.display = 'none'; }, 3000);
    }
    window.showObsidianNotification = showObsidianNotification;
    </script>
    <style>
    .order-tab-root .obsidian-alert {
        position: fixed;
        top: 0; left: 0; width: 100vw; height: 100vh;
        background: rgba(0, 102, 204, 0.95);
        display: none; justify-content: center; align-items: center;
        z-index: 9999; animation: pulse 2s;
    }
    .order-tab-root .obsidian-alert .alert-content {
        background: white; padding: 2rem; border-radius: 20px; text-align: center;
        box-shadow: 0 0 30px rgba(0,0,0,0.3); animation: bounce 1s;
    }
    .order-tab-root .obsidian-alert .large-emoji { font-size: 5rem; margin-bottom: 1rem; }
    .order-tab-root .obsidian-alert .alert-text { font-size: 2rem; font-weight: bold; color: #0066cc; margin: 1rem 0; }
    @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-20px); } }
    </style>
    '''

def discussion_order_tab():
    # 캐릭터/상수 (함수 최상단에 위치)
    CHARACTERS = {"현철님": "🧙‍♂️ 지혜의 현자", "창환님": "🚀 미래의 선구자", "성범님": "🎯 통찰의 대가", "상현님": "🎭 질문의 예술가", "성일님": "💡 혁신의 아이콘", "경호님": "🦾 전략의 마에스트로", "재원님": "⚡️ 기술영업의 달인"}
    VALUES = [
        "Success is not the key to happiness. Happiness is the key to success.\n성공이 행복의 열쇠가 아니라, 행복이 성공의 열쇠다.",
        "I find that the harder I work, the more luck I seem to have. – Thomas Jefferson\n열심히 일 할수록 운이 더 좋아지는 것 같다. – 토머스 제퍼슨",
        # ... (필요시 추가)
    ]
    
    # 다른 탭의 보호된 상태들을 절대 건드리지 않도록 보호
    protected_keys = ['ai_summary_result', 'tts_audio', 'ai_app_summary_result', 'tts_app_audio', 
                     'ai_fable_result', 'tts_fable_audio',
                     'ai_summary_result_backup', 'tts_audio_backup', 'ai_app_summary_result_backup', 'tts_app_audio_backup',
                     'ai_fable_result_backup', 'tts_fable_audio_backup',
                     'ai_summary_result_permanent_backup', 'tts_audio_permanent_backup', 
                     'ai_app_summary_result_permanent_backup', 'tts_app_audio_permanent_backup',
                     'ai_fable_result_permanent_backup', 'tts_fable_audio_permanent_backup']
    
    # 순서/타이머 관련 상태만 초기화 (다른 상태는 보호)
    timer_only_states = {
        'order_generated': False,
        'final_order': [],
        'order_timer_started': False,
        'order_start_time': None,
        'order_duration': timedelta(minutes=15),
        'order_timer_finished': False,
        'order_alarm_enabled': True,
        'order_toast_enabled': True
    }
    
    # 타이머 관련 상태만 안전하게 초기화 (보호된 상태는 절대 건드리지 않음)
    for key, default_value in timer_only_states.items():
        if key not in st.session_state:
            st.session_state[key] = default_value
    
    # 스타일 및 JS (최초 1회만)
    if 'order_js_loaded' not in st.session_state:
        st.markdown("""
        <style>
        .order-tab-root .character-card { background-color: #f8f9fa; padding: 1rem; border-radius: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); margin-bottom: 1rem; }
        .order-tab-root .character-name { color: #0066cc; font-weight: bold; }
        .order-tab-root .timer-display { color: #1f1f1f; font-size: 4rem; font-weight: bold; text-align: center; }
        .order-tab-root .timer-status { font-size: 1.2rem; text-align: center; }
        .order-tab-root .intense-warning { background: linear-gradient(145deg, #ff4b4b, #ff6b6b); color: white; padding: 20px; border-radius: 15px; text-align: center; font-size: 28px; font-weight: bold; margin: 20px 0; animation: blink-intense 0.7s infinite; box-shadow: 0 4px 15px rgba(255, 75, 75, 0.5); }
        .order-tab-root .fullscreen-alert { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(255, 75, 75, 0.95); display: flex; justify-content: center; align-items: center; z-index: 9999; animation: pulse 2s infinite; }
        .order-tab-root .alert-content { background: white; padding: 2rem; border-radius: 20px; text-align: center; box-shadow: 0 0 30px rgba(0,0,0,0.3); animation: bounce 1s infinite; }
        .order-tab-root .large-emoji { font-size: 5rem; margin-bottom: 1rem; }
        .order-tab-root .alert-text { font-size: 2rem; font-weight: bold; color: #ff4b4b; margin: 1rem 0; }
        .order-tab-root .alert-subtext { font-size: 1.2rem; color: #666; }
        @keyframes blink-intense { 0% { transform: scale(1); background: linear-gradient(145deg, #ff4b4b, #ff6b6b); } 50% { transform: scale(1.05); background: linear-gradient(145deg, #ff6b6b, #ff8b8b); } 100% { transform: scale(1); background: linear-gradient(145deg, #ff4b4b, #ff6b6b); } }
        @keyframes pulse { 0% { background: rgba(255, 75, 75, 0.95); } 50% { background: rgba(255, 75, 75, 0.7); } 100% { background: rgba(255, 75, 75, 0.95); } }
        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-20px); } }
        </style>
        """, unsafe_allow_html=True)
        st.markdown(get_alarm_js_scoped(), unsafe_allow_html=True)
        st.markdown(get_toast_notification_js_scoped(), unsafe_allow_html=True)
        st.session_state.order_js_loaded = True
    st.markdown("<div class='order-tab-root'>", unsafe_allow_html=True)
    # Tiro 녹음기능 알림 (한 번만, 정적)
    if 'order_initial_notice_shown' not in st.session_state:
        st.markdown('''
        <div class="notice-container" style="background: linear-gradient(145deg, #0066cc, #0052a3); color: white; padding: 20px; border-radius: 15px; text-align: center; margin: 20px auto; max-width: 600px; animation: slideIn 0.5s ease-out;">
            <div class="notice-icon" style="font-size: 48px; margin-bottom: 10px; display: inline-block;">🎙️</div>
            <div class="notice-text" style="font-size: 24px; font-weight: bold; margin: 10px 0; text-shadow: 2px 2px 4px rgba(0,0,0,0.3);">Tiro 녹음기능을 활성화해 주세요!</div>
            <div class="notice-subtext">
                <div class="highlight" style="background: rgba(255,255,255,0.2); padding: 5px 10px; border-radius: 5px; display: inline-block; margin: 5px 0;">토론 내용 기록을 위해 꼭 필요합니다</div>
                <div class="highlight" style="background: rgba(255,255,255,0.2); padding: 5px 10px; border-radius: 5px; display: inline-block; margin: 5px 0;">시작 전 반드시 확인해 주세요</div>
            </div>
        </div>
        ''', unsafe_allow_html=True)
        st.session_state.order_initial_notice_shown = True
    # 헤딩 색상 흰색으로 변경
    st.markdown('<h1 style="color: #fff;">🎯 독서토론 순서 정하기</h1>', unsafe_allow_html=True)
    st.markdown('<h3 style="color: #fff;">🎲 오늘의 토론 멤버를 확인하세요!</h3>', unsafe_allow_html=True)
    cols = st.columns(len(CHARACTERS))
    for i, (person, character) in enumerate(CHARACTERS.items()):
        with cols[i]:
            st.markdown(f"<div class='character-card'><h3>{character}</h3><p class='character-name'>{person}</p></div>", unsafe_allow_html=True)
    st.markdown("---")
    if not st.session_state.order_generated:
        if st.button("🎯 발표 순서 정하기!", key="order_btn", use_container_width=True):
            with st.spinner("순서를 정하는 중..."):
                # 룰렛 애니메이션 (동적)
                placeholder = st.empty()
                participants = list(CHARACTERS.keys())
                for _ in range(30):
                    random.shuffle(participants)
                    display_text = "\n".join([f"<div style='font-size:28px; font-weight:bold; color:#0066cc;'>{CHARACTERS[p]} <span style='color:#fff;'>{p}</span></div>" for p in participants])
                    placeholder.markdown(f"<div class='order-tab-root'>{display_text}</div>", unsafe_allow_html=True)
                    time.sleep(0.08)
                other_participants = [p for p in participants if p != "현철님"]
                random.shuffle(other_participants)
                st.session_state.final_order = other_participants + ["현철님"]
                st.session_state.order_generated = True
                st.balloons()
    if st.session_state.order_generated:
        col1, col2 = st.columns([1, 1], gap="large")
        with col1:
            st.markdown('<h2 style="color: #fff; font-size: 24px; margin-bottom: 20px;">🎉 발표 순서</h2>', unsafe_allow_html=True)
            for i, person in enumerate(st.session_state.final_order, 1):
                st.markdown(f"<div style='background: linear-gradient(145deg, #ffffff, #f0f0f0); padding: 10px; border-radius: 8px; margin: 5px 0; box-shadow: 3px 3px 6px #d9d9d9, -3px -3px 6px #ffffff;'><div style='color: #0066cc; margin: 0; font-size: 16px; display: flex; align-items: center;'><span style='font-weight: bold; min-width: 24px;'>{i}.</span><span style='margin-left: 8px;'>{person}</span><span style='margin-left: 8px; opacity: 0.8;'>{CHARACTERS[person]}</span></div></div>", unsafe_allow_html=True)
        with col2:
            st.markdown('<h2 style="color: #fff; font-size: 24px; margin-bottom: 20px;">⏱️ 토론 타이머</h2>', unsafe_allow_html=True)
            
            # 타이머 시간 설정 슬라이더 (1~30분, 기본 15분)
            timer_duration = st.slider("⏰ 시간 (분)", min_value=1, max_value=30, value=int(st.session_state.order_duration.total_seconds() // 60), key="order_timer_duration")
            st.session_state.order_duration = timedelta(minutes=timer_duration)

            if not st.session_state.order_timer_started:
                if st.button("⏱️ 토론 시작하기", use_container_width=True):
                    # 다른 탭의 세션 상태 보호를 위한 백업
                    for key in protected_keys:
                        if key in st.session_state and st.session_state[key] is not None:
                            st.session_state[f"{key}_protected"] = st.session_state[key]
                    
                    # 타이머만 시작
                    st.session_state.order_timer_started = True
                    st.session_state.order_start_time = datetime.now().timestamp()
                    st.session_state.order_timer_finished = False
            else:
                if st.button("🔄 타이머 리셋", use_container_width=True):
                    # 다른 탭의 세션 상태 보호를 위한 백업 복원
                    for key in protected_keys:
                        protected_key = f"{key}_protected"
                        if protected_key in st.session_state:
                            st.session_state[key] = st.session_state[protected_key]
                    
                    # 타이머 관련 상태만 리셋 (보호된 상태는 절대 건드리지 않음)
                    st.session_state.order_timer_started = False
                    st.session_state.order_start_time = None
                    st.session_state.order_timer_finished = False
                    
                # JS 기반 실시간 타이머 표시
                start_time = st.session_state.order_start_time
                duration = int(st.session_state.order_duration.total_seconds())  # 초 단위
                audio_base64 = st.session_state.get('order_end_audio', '')
                
                # 보호된 상태 키들을 JavaScript로 전달
                protected_keys_js = str(protected_keys).replace("'", '"')
                
                # 타이머+음성 HTML 삽입 (종료 시 src를 동적으로 할당하고 play)
                components.html(f'''
                <div id='timer' style='font-size:2rem; text-align:center; color:#fff; background:#222; border-radius:10px; padding:10px 0; margin:10px 0;'></div>
                <audio id='endAudio' style='display:none;'></audio>
                <script>
                const start = {start_time} * 1000;
                const duration = {duration} * 1000;
                const audioBase64 = "{audio_base64}";
                const protectedKeys = {protected_keys_js};
                
                // 세션 상태 보호를 위한 함수
                async function protectSessionState() {{
                    try {{
                        // 타이머 종료 상태 설정
                        await window.parent.stStreamlitClient.setComponentValue(
                            'order_timer_finished',
                            true,
                            {{ fromUi: true }}
                        );
                        
                        // 보호된 상태들의 백업 복원
                        for (const key of protectedKeys) {{
                            const protectedKey = `${{key}}_protected`;
                            if (window.parent.sessionStorage.getItem(protectedKey)) {{
                                await window.parent.stStreamlitClient.setComponentValue(
                                    key,
                                    window.parent.sessionStorage.getItem(protectedKey),
                                    {{ fromUi: true }}
                                );
                            }}
                        }}
                    }} catch (error) {{
                        console.error('Error protecting session state:', error);
                    }}
                }}

                function updateTimer() {{
                    const now = new Date().getTime();
                    const elapsed = now - start;
                    const remaining = duration - elapsed;
                    
                    if (remaining <= 0) {{
                        document.getElementById('timer').innerHTML = '시간 종료!';
                        if (audioBase64) {{
                            const audio = document.getElementById('endAudio');
                            audio.src = `data:audio/mp3;base64,${{audioBase64}}`;
                            audio.play();
                        }}
                        // 타이머 종료 시 세션 상태 보호
                        protectSessionState();
                        clearInterval(timerInterval);
                    }} else {{
                        const minutes = Math.floor(remaining / 60000);
                        const seconds = Math.floor((remaining % 60000) / 1000);
                        document.getElementById('timer').innerHTML = 
                            `${{minutes}}:${{seconds.toString().padStart(2, '0')}}`;
                    }}
                }}

                const timerInterval = setInterval(updateTimer, 1000);
                updateTimer();
                </script>
                ''', height=80)
    st.markdown("---")
    if st.button("🔄 다시 정하기", key="order_reset", use_container_width=True):
        # 다른 탭의 세션 상태 보호를 위한 백업 복원 (우화 포함)
        for key in protected_keys:
            protected_key = f"{key}_protected"
            if protected_key in st.session_state:
                st.session_state[key] = st.session_state[protected_key]
        
        # 타이머 관련 세션 상태만 초기화 (보호된 상태는 절대 건드리지 않음)
        st.session_state.order_generated = False
        st.session_state.order_timer_started = False
        st.session_state.order_start_time = None
        st.session_state.order_timer_finished = False
        st.session_state.final_order = []
    st.markdown("</div>", unsafe_allow_html=True)

def main():
    # 독서토론 검색/조회 탭의 세션 상태를 영구적으로 보호 - 더 강화된 보호
    protected_states = {
        'ai_summary_result': None,
        'tts_audio': None,
        'ai_app_summary_result': None,
        'tts_app_audio': None,
        'ai_fable_result': None,
        'tts_fable_audio': None
    }
    
    # 보호된 상태들을 안전하게 초기화 (기존 값이 있으면 유지)
    for key, default_value in protected_states.items():
        if key not in st.session_state:
            st.session_state[key] = default_value
        # 추가 보호: None이 아닌 값이 있다면 백업
        if st.session_state[key] is not None:
            # 일반 백업
            st.session_state[f"{key}_backup"] = st.session_state[key]
            # 보호된 백업
            st.session_state[f"{key}_protected"] = st.session_state[key]
            # 영구 백업
            st.session_state[f"{key}_permanent_backup"] = st.session_state[key]
    
    # 타이머 종료 시 백업 복원
    if st.session_state.get('order_timer_finished', False):
        for key in protected_states.keys():
            # 영구 백업에서 복원 시도
            permanent_backup_key = f"{key}_permanent_backup"
            if permanent_backup_key in st.session_state and st.session_state[permanent_backup_key] is not None:
                st.session_state[key] = st.session_state[permanent_backup_key]
            # 보호된 백업에서 복원 시도
            elif f"{key}_protected" in st.session_state and st.session_state[f"{key}_protected"] is not None:
                st.session_state[key] = st.session_state[f"{key}_protected"]
            # 일반 백업에서 복원 시도
            elif f"{key}_backup" in st.session_state and st.session_state[f"{key}_backup"] is not None:
                st.session_state[key] = st.session_state[f"{key}_backup"]
    
    # 타이머 관련 상태들도 안전하게 초기화
    timer_states = {
        'order_generated': False,
        'final_order': [],
        'order_timer_started': False,
        'order_start_time': None,
        'order_duration': timedelta(minutes=15),
        'order_timer_finished': False,
        'order_alarm_enabled': True,
        'order_toast_enabled': True
    }
    
    for key, default_value in timer_states.items():
        if key not in st.session_state:
            st.session_state[key] = default_value
   
    tab1, tab2, tab3, tab4, tab_order = st.tabs(["요약/적용 파일 등록", "적용 파일 생성", "독서토론 검색/조회", "이야기 재생", "발표 순서/타이머"])
    
    with tab1:
        st.header("요약/적용 파일 등록")
        

        col1, col2 = st.columns(2)
        with col1:
            st.subheader("파일 업로드")
            uploaded_file = st.file_uploader("요약/적용 파일 업로드 (txt, md, pdf)", type=["txt", "md","pdf"])
        with col2:
            st.subheader("텍스트 직접 입력")
            text_input = st.text_area("텍스트를 복사해 넣으세요", height=200)
        # 책 제목 선택 (selectbox, 기본값: Good to Great)
        book_title = st.selectbox(
            "책 제목",
            ["AX 100배의 법칙", "성장의 묘약","퍼스널 MBA", "레이달리오의 원칙", "Good to Great"],
            index=0
        )
        material_type = st.selectbox("자료 유형", ["요약", "적용"])
        openai_api_key = os.getenv('OPENAI_API_KEY')
        file_name = None
        raw_text = None
        # --- 추가: AI 프롬프트용 텍스트 박스 ---
        extra_prompt_reg = st.text_area("AI 프롬프트에 추가로 참고할 내용(선택)", key="reg_extra_prompt", placeholder="특정 관점, 강조점, 추가 지시사항 등 자유롭게 입력하세요.", height=80)
        # ---
        if uploaded_file:
            file_name = uploaded_file.name
            file_extension = file_name.lower().split('.')[-1] if '.' in file_name else ''
            
            # PDF 파일 처리
            if file_extension == 'pdf':
                try:
                    import PyPDF2
                    import io
                    
                    # 파일을 BytesIO로 변환
                    pdf_bytes = uploaded_file.read()
                    pdf_file = io.BytesIO(pdf_bytes)
                    
                    # PDF 리더 생성
                    pdf_reader = PyPDF2.PdfReader(pdf_file)
                    
                    # 모든 페이지의 텍스트 추출
                    raw_text = ""
                    for page_num in range(len(pdf_reader.pages)):
                        page = pdf_reader.pages[page_num]
                        page_text = page.extract_text()
                        raw_text += f"\n--- 페이지 {page_num + 1} ---\n{page_text}\n"
                    
                    if raw_text.strip():
                        st.success(f"PDF에서 텍스트가 성공적으로 추출되었습니다! (총 {len(pdf_reader.pages)}페이지)")
                        st.info(f"추출된 텍스트 길이: {len(raw_text)}자")
                    else:
                        st.warning("PDF에서 텍스트를 추출할 수 없습니다. 이미지 기반 PDF이거나 보호된 PDF일 수 있습니다.")
                        raw_text = "[PDF 텍스트 추출 실패] 수동으로 텍스트를 입력해 주세요."
                        
                except ImportError:
                    st.error("PDF 처리를 위해 PyPDF2 라이브러리가 필요합니다.")
                    st.code("pip install PyPDF2", language="bash")
                    raw_text = "[PDF 라이브러리 없음] PyPDF2를 설치하거나 텍스트를 수동으로 입력해 주세요."
                except Exception as e:
                    st.error(f"PDF 처리 중 오류: {str(e)}")
                    st.info("대안으로 pdfplumber를 시도해보겠습니다...")
                    
                    # 대안: pdfplumber 시도
                    try:
                        import pdfplumber
                        
                        uploaded_file.seek(0)  # 파일 포인터 초기화
                        with pdfplumber.open(uploaded_file) as pdf:
                            raw_text = ""
                            for page_num, page in enumerate(pdf.pages):
                                page_text = page.extract_text()
                                if page_text:
                                    raw_text += f"\n--- 페이지 {page_num + 1} ---\n{page_text}\n"
                        
                        if raw_text.strip():
                            st.success(f"pdfplumber로 PDF 텍스트 추출 성공! (총 {len(pdf.pages)}페이지)")
                        else:
                            raw_text = "[PDF 텍스트 추출 실패] 수동으로 텍스트를 입력해 주세요."
                            
                    except ImportError:
                        st.error("PDF 처리를 위해 pdfplumber 라이브러리도 필요합니다.")
                        st.code("pip install pdfplumber", language="bash")
                        raw_text = "[PDF 라이브러리 없음] PyPDF2 또는 pdfplumber를 설치하거나 텍스트를 수동으로 입력해 주세요."
                    except Exception as e2:
                        st.error(f"pdfplumber로도 PDF 처리 실패: {str(e2)}")
                        raw_text = "[PDF 텍스트 추출 실패] 수동으로 텍스트를 입력해 주세요."
            
            # 텍스트 파일 처리 (txt, md)
            else:
                try:
                    # 먼저 UTF-8 시도
                    raw_text = uploaded_file.read().decode('utf-8')
                except UnicodeDecodeError:
                    # UTF-8 실패 시 다른 인코딩들 시도
                    uploaded_file.seek(0)  # 파일 포인터를 처음으로 되돌림
                    file_bytes = uploaded_file.read()
                    
                    # 한국어에서 자주 사용되는 인코딩들을 순서대로 시도
                    encodings_to_try = ['cp949', 'euc-kr', 'utf-8-sig', 'latin-1']
                    
                    raw_text = None
                    for encoding in encodings_to_try:
                        try:
                            raw_text = file_bytes.decode(encoding)
                            st.info(f"파일이 {encoding} 인코딩으로 성공적으로 읽혔습니다.")
                            break
                        except UnicodeDecodeError:
                            continue
                    
                    if raw_text is None:
                        # 모든 인코딩이 실패한 경우, errors='ignore'로 강제 읽기
                        raw_text = file_bytes.decode('utf-8', errors='ignore')
                        st.warning("파일 인코딩을 자동으로 감지할 수 없어서 일부 문자가 깨질 수 있습니다.")
        elif text_input.strip():
            file_name = f"manual_input_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
            raw_text = text_input
        if st.button("등록 (AI 요약 및 저장)"):
            if not raw_text:
                st.warning("파일 업로드 또는 텍스트 입력이 필요합니다.")
            elif not openai_api_key:
                st.error("OpenAI API 키가 설정되지 않았습니다.")
            else:
                with st.spinner("AI 요약 중입니다..."):
                    try:
                        # 파일 업로드든 직접 입력이든 모두 AI 요약 후 저장
                        if uploaded_file:
                            st.info(f"📄 {file_name} 파일을 AI가 요약 중입니다...")
                        else:
                            st.info("📝 입력된 텍스트를 AI가 요약 중입니다...")
                        
                        # 모든 경우에 AI 요약 실행
                        summary = ai_summarize(raw_text, st.session_state.selected_model, extra_prompt_reg)
                        saved = save_material(book_title, file_name, summary, "summary" if material_type=="요약" else "application")
                        
                        if saved:
                            st.success("AI 요약 및 저장 완료!")
                            
                            # 원본과 요약본 비교 표시
                            if uploaded_file:
                                st.markdown("### 📊 원본 vs AI 요약 비교")
                                col1, col2 = st.columns(2)
                                with col1:
                                    st.markdown("#### 📄 원본 파일 내용")
                                    st.markdown(f"**길이**: {len(raw_text):,}자")
                                    with st.expander("원본 내용 보기", expanded=False):
                                        st.markdown(format_bullet_points(raw_text[:1000] + "..." if len(raw_text) > 1000 else raw_text))
                                with col2:
                                    st.markdown("#### 🤖 AI 요약 결과")
                                    st.markdown(f"**길이**: {len(summary):,}자")
                                    st.markdown(format_bullet_points(summary))
                            else:
                                st.markdown("### 🤖 AI 요약 결과")
                                st.markdown(format_bullet_points(summary))
                        
                    except Exception as e:
                        st.error(f"AI 요약/저장 중 오류: {str(e)}")

    with tab2:
        st.header("적용 파일 생성")
        openai_api_key = os.getenv('OPENAI_API_KEY')
        # 요약 파일, 기존 적용 파일 선택
        summaries = get_materials("summary")
        applications = get_materials("application")
        summary_options = [f"{s['book_title']} - {s['file_name']}" for s in summaries]
        application_options = [f"{a['book_title']} - {a['file_name']}" for a in applications]
        selected_summary = st.selectbox("요약 파일 선택", options=summary_options)
        selected_application = st.selectbox("기존 적용 파일 선택", options=application_options)
        extra_prompt = st.text_area("AI 프롬프트에 추가로 참고할 내용(선택)", placeholder="특정 관점, 강조점, 추가 지시사항 등 자유롭게 입력하세요.", height=80)
        if st.button("AI 적용 파일 생성 및 저장"):
            if not openai_api_key:
                st.error("OpenAI API 키가 설정되지 않았습니다.")
            else:
                with st.spinner("AI가 적용 파일을 생성 중입니다..."):
                    try:
                        summary_text = summaries[summary_options.index(selected_summary)]['content']
                        application_text = applications[application_options.index(selected_application)]['content']
                        result = ai_generate_application(summary_text, application_text, st.session_state.selected_model, extra_prompt)
                        # 저장
                        book_title = summaries[summary_options.index(selected_summary)]['book_title']
                        file_name = f"AI_적용파일_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"
                        saved = save_material(book_title, file_name, result, "application")
                        if saved:
                            st.success("적용 파일 생성 및 저장 완료!")
                            st.markdown("### 생성된 적용 파일 미리보기")
                            st.markdown(result)
                    except Exception as e:
                        st.error(f"AI 적용 파일 생성/저장 중 오류: {str(e)}")

    with tab3:
        st.header("독서토론 검색/조회")
        
        # 백업된 상태가 있다면 복원 (추가 보호)
        for key in protected_states.keys():
            backup_key = f"{key}_backup"
            permanent_backup_key = f"{key}_permanent_backup"
            
            # 영구 백업에서 복원 (최우선)
            if permanent_backup_key in st.session_state and st.session_state[permanent_backup_key] is not None:
                if st.session_state[key] is None:
                    st.session_state[key] = st.session_state[permanent_backup_key]
                    # 일반 백업도 동시에 복원
                    st.session_state[backup_key] = st.session_state[permanent_backup_key]
            # 일반 백업에서 복원 (차선)
            elif backup_key in st.session_state and st.session_state[backup_key] is not None:
                if st.session_state[key] is None:
                    st.session_state[key] = st.session_state[backup_key]
        
        subtab1, subtab2, subtab3 = st.tabs(["요약 파일", "적용 파일", "우화"])
        with subtab1:
            st.markdown("<div class='order-tab-root'>", unsafe_allow_html=True)
            st.subheader("요약 파일 검색/AI 요약/음성 생성")
            summaries = get_materials("summary")
            previous_topic = st.text_input("이전 토론 주제", placeholder="이전 독서 토론의 주제를 입력해주세요", key="prev_topic_tts")
            if summaries:
                summary_options = [f"{s['book_title']} - {s['file_name']} ({s['created_at'].strftime('%Y-%m-%d')})" for s in summaries]
                selected_idx = st.selectbox("요약 파일 선택 (최신순)", range(len(summary_options)), format_func=lambda i: summary_options[i], key="summary_selectbox")
                selected_summary = summaries[selected_idx]
                st.write(f"### {selected_summary['file_name']}")
                st.markdown(format_bullet_points(selected_summary['content']))
                st.write(f"*등록일: {selected_summary['created_at'].strftime('%Y-%m-%d')}*")
                extra_prompt_summary = st.text_area("AI 프롬프트에 추가로 참고할 내용(선택)", key="summary_extra_prompt", placeholder="특정 관점, 강조점, 추가 지시사항 등 자유롭게 입력하세요.", height=80)
                if st.button("AI 요약"):
                    with st.spinner("AI가 핵심 요약을 생성 중입니다..."):
                        try:
                            ai_summary = ai_summarize_keypoints(selected_summary['content'], st.session_state.selected_model, extra_prompt_summary)
                            st.session_state['ai_summary_result'] = ai_summary
                            # 백업도 함께 저장
                            st.session_state['ai_summary_result_backup'] = ai_summary
                            # 영구 백업도 함께 저장
                            st.session_state['ai_summary_result_permanent_backup'] = ai_summary
                            
                            st.success("AI 요약이 생성되었습니다! 음성 생성 버튼을 클릭하면 음성과 함께 DB에 저장됩니다.")
                            
                        except Exception as e:
                            st.error(f"AI 요약 중 오류: {str(e)}")
                if st.session_state['ai_summary_result']:
                    st.markdown("### 비즈니스 실전 적용 핵심")
                    st.markdown(format_bullet_points(st.session_state['ai_summary_result']))
                    # Tiro 녹음기능 알림 (Streamlit 스타일, 항상 보이게)
                    st.markdown(
                        '''
                        <div style="background: linear-gradient(145deg, #0066cc, #0052a3); color: white; padding: 20px; border-radius: 15px; text-align: center; margin: 20px 0; font-size: 1.3rem; font-weight: bold;">
                            🎙️ Tiro 녹음기능을 활성화해 주세요!<br>
                            <span style="font-size: 1rem; font-weight: normal;">토론 내용 기록을 위해 꼭 필요합니다.<br>시작 전 반드시 확인해 주세요.</span>
                        </div>
                        ''',
                        unsafe_allow_html=True
                    )
                if st.button("음성 생성", key="summary_tts_btn"):
                    with st.spinner("음성을 생성하고 있습니다..."):
                        try:
                            opening_ment = f"안녕하세요. 좋은 아침입니다. 지난번 시간에는 {previous_topic if previous_topic else '이전 주제'}의 내용으로 독서토론을 진행했습니다. 그럼 오늘 독서 토론 내용을 요약해 드리겠습니다."
                            full_text = f"""
{opening_ment}
\n요약 내용입니다.\n{selected_summary['content']}"""
                            if st.session_state.get('ai_summary_result'):
                                full_text += f"\n\n비즈니스 실전 적용 핵심 내용입니다.\n{st.session_state['ai_summary_result']}"
                            full_text += "\n\n즐거운 독서 토론 되세요."
                            summarized_text = summarize_for_tts(full_text)
                            tts_audio = text_to_speech(summarized_text)
                            if tts_audio:
                                st.session_state['tts_audio'] = tts_audio
                                # 백업도 함께 저장
                                st.session_state['tts_audio_backup'] = tts_audio
                                # 영구 백업도 함께 저장
                                st.session_state['tts_audio_permanent_backup'] = tts_audio
                                
                                # 음성 데이터를 base64에서 추출하여 DB 저장
                                try:
                                    # HTML에서 base64 데이터 추출
                                    import re
                                    base64_match = re.search(r'data:audio/mp3;base64,([^"]+)', tts_audio)
                                    if base64_match:
                                        audio_base64 = base64_match.group(1)
                                        audio_binary = base64.b64decode(audio_base64)
                                        
                                        # DB에 음성 데이터와 함께 저장 (원본 + AI 요약 포함)
                                        ai_summary_content = st.session_state.get('ai_summary_result', '')
                                        combined_content = f"=== 📝 원본 요약 파일 ===\n{selected_summary['content']}\n\n=== 🤖 AI 생성 핵심 요약 ===\n{ai_summary_content}" if ai_summary_content else selected_summary['content']
                                        save_success = save_reading_discussion_record(
                                            book_title=selected_summary['book_title'],
                                            source_file_name=selected_summary['file_name'],
                                            content_type='summary',
                                            ai_content=combined_content,
                                            audio_data=audio_binary,
                                            audio_filename=f"summary_{selected_summary['book_title']}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.mp3",
                                            model_used=st.session_state.selected_model,
                                            previous_topic=previous_topic
                                        )
                                        if save_success:
                                            st.success("음성이 생성되고 요약 텍스트와 함께 DB에 저장되었습니다!")
                                except Exception as db_e:
                                    st.warning(f"음성은 생성되었지만 DB 저장 중 오류: {str(db_e)}")
                        except Exception as e:
                            st.error(f"음성 생성 중 오류: {str(e)}")
                if st.session_state['tts_audio']:
                    st.markdown(st.session_state['tts_audio'], unsafe_allow_html=True)
                    # Tiro 녹음기능 알림 추가
                    st.markdown(get_obsidian_notification_js_scoped(), unsafe_allow_html=True)
                    st.markdown("<script>showObsidianNotification();</script>", unsafe_allow_html=True)
                st.markdown("</div>", unsafe_allow_html=True)
            else:
                st.markdown("</div>", unsafe_allow_html=True)
                st.info("등록된 요약 파일이 없습니다.")
        with subtab2:
            st.subheader("적용 파일 검색/AI 요약/음성 생성")
            applications = get_materials("application")
            next_topic = st.text_input("다음 토론 주제", placeholder="다음 독서 토론의 주제를 입력해주세요", key="next_topic_tts")
            if applications:
                application_options = [f"{a['book_title']} - {a['file_name']} ({a['created_at'].strftime('%Y-%m-%d')})" for a in applications]
                selected_idx = st.selectbox("적용 파일 선택 (최신순)", range(len(application_options)), format_func=lambda i: application_options[i], key="app_selectbox")
                selected_application = applications[selected_idx]
                st.write(f"### {selected_application['file_name']}")
                st.markdown(format_bullet_points(selected_application['content']))
                st.write(f"*등록일: {selected_application['created_at'].strftime('%Y-%m-%d')}*")
                extra_prompt_app = st.text_area("AI 프롬프트에 추가로 참고할 내용(선택)", key="app_extra_prompt", placeholder="특정 관점, 강조점, 추가 지시사항 등 자유롭게 입력하세요.", height=80)
                if st.button("AI 요약", key="app_ai_summary"):
                    with st.spinner("AI가 적용 파일을 요약 중입니다..."):
                        try:
                            ai_app_summary = ai_summarize_application_summary(selected_application['content'], st.session_state.selected_model, extra_prompt_app)
                            st.session_state['ai_app_summary_result'] = ai_app_summary
                            # 백업도 함께 저장
                            st.session_state['ai_app_summary_result_backup'] = ai_app_summary
                            # 영구 백업도 함께 저장
                            st.session_state['ai_app_summary_result_permanent_backup'] = ai_app_summary
                            
                            st.success("AI 적용 파일 요약이 생성되었습니다! 음성 생성 버튼을 클릭하면 음성과 함께 DB에 저장됩니다.")
                        except Exception as e:
                            st.error(f"AI 요약 중 오류: {str(e)}")
                if st.session_state['ai_app_summary_result']:
                    st.markdown("### 적용 파일 요약 및 총평 (AI)")
                    st.markdown(st.session_state['ai_app_summary_result'])
                if st.button("음성 생성", key="app_tts"):
                    with st.spinner("음성을 생성하고 있습니다..."):
                        try:
                            opening_ment = "즐거운 독서토론 되셨는지요. 이번 독서토론의 적용 파일에 대한 AI 요약과 총평을 해 드리겠습니다."
                            closing_ment = f"다음 시간에는 {next_topic if next_topic else '다음 주제'}에 대한 독서 토론을 진행할 예정입니다."
                            tts_text = f"{opening_ment}\n" + (st.session_state.get('ai_app_summary_result') or '') + f"\n{closing_ment}"
                            summarized_text = summarize_for_tts(tts_text)
                            tts_app_audio = text_to_speech(summarized_text)
                            if tts_app_audio:
                                st.session_state['tts_app_audio'] = tts_app_audio
                                # 백업도 함께 저장
                                st.session_state['tts_app_audio_backup'] = tts_app_audio
                                # 영구 백업도 함께 저장
                                st.session_state['tts_app_audio_permanent_backup'] = tts_app_audio
                                
                                # 적용 파일 음성 데이터를 base64에서 추출하여 DB 저장
                                try:
                                    import re
                                    base64_match = re.search(r'data:audio/mp3;base64,([^"]+)', tts_app_audio)
                                    if base64_match:
                                        audio_base64 = base64_match.group(1)
                                        audio_binary = base64.b64decode(audio_base64)
                                        
                                        # DB에 적용 파일 음성 데이터와 함께 저장
                                        # 원본 적용 파일 + AI 요약을 함께 저장
                                        ai_app_content = st.session_state.get('ai_app_summary_result', '')
                                        combined_content = f"=== 📝 원본 적용 파일 ===\n{selected_application['content']}\n\n=== 🤖 AI 요약 및 총평 ===\n{ai_app_content}" if ai_app_content else selected_application['content']
                                        
                                        save_success = save_reading_discussion_record(
                                            book_title=selected_application['book_title'],
                                            source_file_name=selected_application['file_name'],
                                            content_type='application',
                                            ai_content=combined_content,
                                            audio_data=audio_binary,
                                            audio_filename=f"application_{selected_application['book_title']}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.mp3",
                                            model_used=st.session_state.selected_model,
                                            extra_prompt=extra_prompt_app,
                                            next_topic=next_topic
                                        )
                                        if save_success:
                                            st.success("적용 파일 음성이 생성되고 텍스트와 함께 DB에 저장되었습니다!")
                                except Exception as db_e:
                                    st.warning(f"음성은 생성되었지만 DB 저장 중 오류: {str(db_e)}")
                        except Exception as e:
                            st.error(f"음성 생성 중 오류: {str(e)}")
                if st.session_state['tts_app_audio']:
                    st.markdown(st.session_state['tts_app_audio'], unsafe_allow_html=True)
            else:
                st.info("등록된 적용 파일이 없습니다.")
        
        with subtab3:
            st.subheader("우화 생성/음성 생성")
            summaries = get_materials("summary")
            if summaries:
                summary_options = [f"{s['book_title']} - {s['file_name']} ({s['created_at'].strftime('%Y-%m-%d')})" for s in summaries]
                selected_idx = st.selectbox("요약 파일 선택 (최신순)", range(len(summary_options)), format_func=lambda i: summary_options[i], key="fable_summary_selectbox")
                selected_summary = summaries[selected_idx]
                
                # 우화 스타일 선택
                fable_types = [
                    "하모니아",  # 새로운 옵션을 첫 번째로 추가
                    "이솝우화", "탈무드", "성경이야기", "예수님과 12사도", "4대 성인 대화(예수님, 부처님, 공자님, 소크라테스님)", 
                    "장자 이야기", "노자의 도덕경", "삼국지의 제갈량", "초한지의 장량", "주역", "제자백가",
                    "피터 드러커, 이나모리 가즈오, 데일 카네기 (기업 및 인재 경영의 대가들)",
                    "마이클 포터, 헨리 민츠버그, 게리 하멜, 클레이튼 크리스텐슨 (경영전략의 대가들)",
                    "존 폰노이만, 존 내쉬, 토마스 셀링, 애덤 브랜드버거 (게임이론의 대가들)",
                    "제프리 힌튼, 얀 르쿤, 요슈아 벤지오, 앤드류 응 (AI 4대 석학)"
                ]
                selected_fable_type = st.selectbox("우화 스타일 선택", fable_types, key="fable_type_select", index=0)  # index=0으로 하모니아를 기본값으로 설정
                
                # 오프닝 멘트와 다음 토론 주제 입력란
                col1, col2 = st.columns(2)
                with col1:
                    opening_ment_custom = st.text_area("오프닝 멘트 (선택)", key="fable_opening_ment", 
                                                     value="즐거운 독서토론 되셨는지요. 이번 독서토론 내용을 바탕으로 한 우화를 들려드리겠습니다.", 
                                                     height=80)
                with col2:
                    next_topic_fable = st.text_input("다음 토론 주제", placeholder="다음 독서 토론의 주제를 입력해주세요", key="next_topic_fable")
                
                st.write(f"### {selected_summary['file_name']}")
                st.markdown(format_bullet_points(selected_summary['content']))
                st.write(f"*등록일: {selected_summary['created_at'].strftime('%Y-%m-%d')}*")
                
                extra_prompt_fable = st.text_area("AI 프롬프트에 추가로 참고할 내용(선택)", key="fable_extra_prompt", placeholder="특정 관점, 강조점, 추가 지시사항 등 자유롭게 입력하세요.", height=80)
                
                if st.button("AI 우화 생성", key="fable_ai_generate"):
                    with st.spinner(f"AI가 {selected_fable_type} 스타일의 우화를 생성 중입니다..."):
                        try:
                            ai_fable = ai_generate_fable(selected_summary['content'], selected_fable_type, st.session_state.selected_model, extra_prompt_fable)
                            st.session_state['ai_fable_result'] = ai_fable
                            # 백업도 함께 저장
                            st.session_state['ai_fable_result_backup'] = ai_fable
                            # 영구 백업도 함께 저장
                            st.session_state['ai_fable_result_permanent_backup'] = ai_fable
                            
                            st.success("AI 우화가 생성되었습니다! 음성 생성 버튼을 클릭하면 음성과 함께 DB에 저장됩니다.")
                            
                        except Exception as e:
                            st.error(f"AI 우화 생성 중 오류: {str(e)}")
                
                if st.session_state['ai_fable_result']:
                    st.markdown("### 생성된 우화")
                    st.markdown(st.session_state['ai_fable_result'])
                
                if st.button("음성 생성", key="fable_tts"):
                    if not st.session_state.get('ai_fable_result'):
                        st.warning("먼저 AI 우화를 생성해 주세요.")
                    else:
                        with st.spinner("음성을 생성하고 있습니다..."):
                            try:
                                # 오프닝 멘트 + 우화 + 클로징 멘트 조합
                                tts_parts = []
                                if opening_ment_custom and opening_ment_custom.strip():
                                    tts_parts.append(opening_ment_custom.strip())
                                
                                if st.session_state.get('ai_fable_result'):
                                    tts_parts.append(st.session_state['ai_fable_result'])
                                
                                # 다음 토론 주제 기반 클로징 멘트 생성
                                if next_topic_fable and next_topic_fable.strip():
                                    closing_ment = f"다음 시간에는 {next_topic_fable.strip()}에 대한 독서 토론을 진행할 예정입니다."
                                    tts_parts.append(closing_ment)
                                
                                tts_text = "\n".join(tts_parts)
                                summarized_text = summarize_for_tts(tts_text, max_length=4000)  # 1분 30초 분량으로 길이 조정
                                tts_fable_audio = text_to_speech_fable(summarized_text, selected_fable_type)
                                if tts_fable_audio:
                                    st.session_state['tts_fable_audio'] = tts_fable_audio
                                    # 백업도 함께 저장
                                    st.session_state['tts_fable_audio_backup'] = tts_fable_audio
                                    # 영구 백업도 함께 저장
                                    st.session_state['tts_fable_audio_permanent_backup'] = tts_fable_audio
                                    
                                    # 우화 음성 데이터를 base64에서 추출하여 DB 저장
                                    try:
                                        import re
                                        base64_match = re.search(r'data:audio/mp3;base64,([^"]+)', tts_fable_audio)
                                        if base64_match:
                                            audio_base64 = base64_match.group(1)
                                            audio_binary = base64.b64decode(audio_base64)
                                            
                                            # DB에 우화 음성 데이터와 함께 저장
                                            save_success = save_reading_discussion_record(
                                                book_title=selected_summary['book_title'],
                                                source_file_name=selected_summary['file_name'],
                                                content_type='fable',
                                                ai_content=st.session_state.get('ai_fable_result', ''),
                                                audio_data=audio_binary,
                                                audio_filename=f"fable_{selected_fable_type}_{selected_summary['book_title']}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.mp3",
                                                fable_type=selected_fable_type,
                                                model_used=st.session_state.selected_model,
                                                extra_prompt=extra_prompt_fable,
                                                opening_ment=opening_ment_custom,
                                                next_topic=next_topic_fable
                                            )
                                            if save_success:
                                                st.success("우화 음성이 생성되고 텍스트와 함께 DB에 저장되었습니다!")
                                    except Exception as db_e:
                                        st.warning(f"음성은 생성되었지만 DB 저장 중 오류: {str(db_e)}")
                            except Exception as e:
                                st.error(f"음성 생성 중 오류: {str(e)}")
                
                if st.session_state['tts_fable_audio']:
                    st.markdown(st.session_state['tts_fable_audio'], unsafe_allow_html=True)
            else:
                st.info("등록된 요약 파일이 없습니다.")
    
    with tab4:
        st.header("🎵 이야기 재생")
        st.write("저장된 AI 요약과 우화 콘텐츠를 조회하고 음성을 재생할 수 있습니다.")
        
        # 데이터 개수 선택
        col1, col2 = st.columns([3, 1])
        with col1:
            record_count = st.selectbox(
                "표시할 최근 레코드 수",
                [3, 5, 10, 15, 20, 30, 50],
                index=2,  # 디폴트 10개
                key="record_count_playback"
            )
        with col2:
            if st.button("🔄 새로고침", key="refresh_playback"):
                st.rerun()
        
        # 최근 N개 데이터 가져오기
        all_records = get_reading_discussion_records()
        filtered_records = all_records[:record_count]
        
        if filtered_records:
            # 헤더와 일괄 삭제 기능
            col_header1, col_header2 = st.columns([3, 1])
            with col_header1:
                st.write(f"### 📋 총 {len(filtered_records)}개의 기록이 있습니다.")
            with col_header2:
                if st.button("🗑️ 전체 삭제", key="delete_all_btn", type="secondary", help="현재 필터링된 모든 기록을 삭제합니다"):
                    st.session_state["confirm_delete_all"] = True
            
            # 전체 삭제 확인
            if st.session_state.get("confirm_delete_all", False):
                st.error("🚨 **정말로 현재 표시된 모든 기록을 삭제하시겠습니까?**")
                st.warning(f"⚠️ **{len(filtered_records)}개의 기록**이 영구 삭제됩니다. 복구할 수 없습니다!")
                
                col_all1, col_all2, col_all3 = st.columns([1, 1, 2])
                with col_all1:
                    if st.button("✅ 예, 모두 삭제", key="confirm_delete_all_yes", type="primary"):
                        deleted_count = 0
                        for record in filtered_records:
                            if delete_reading_discussion_record(record['id']):
                                deleted_count += 1
                        
                        if deleted_count > 0:
                            st.success(f"총 {deleted_count}개의 기록이 성공적으로 삭제되었습니다.")
                            if "confirm_delete_all" in st.session_state:
                                del st.session_state["confirm_delete_all"]
                            time.sleep(1)
                            st.rerun()
                        else:
                            st.error("삭제 중 오류가 발생했습니다.")
                with col_all2:
                    if st.button("❌ 아니오, 취소", key="confirm_delete_all_no", type="secondary"):
                        if "confirm_delete_all" in st.session_state:
                            del st.session_state["confirm_delete_all"]
                        st.rerun()
                
                st.markdown("---")
            
            for i, record in enumerate(filtered_records):
                with st.expander(f"{'📝' if record['content_type'] == 'summary' else '📋' if record['content_type'] == 'application' else '📚'} {record['book_title']} - {record['content_type'].upper()} ({record['created_at'].strftime('%Y-%m-%d %H:%M')})"):
                    # 메타데이터 정보
                    meta_col1, meta_col2 = st.columns(2)
                    with meta_col1:
                        st.write(f"**📖 책 제목:** {record['book_title']}")
                        st.write(f"**📄 원본 파일:** {record['source_file_name'] or 'N/A'}")
                        st.write(f"**🤖 사용 모델:** {record['model_used'] or 'N/A'}")
                    with meta_col2:
                        if record['content_type'] == 'fable':
                            st.write(f"**🎭 우화 스타일:** {record['fable_type'] or 'N/A'}")
                        if record['next_topic']:
                            st.write(f"**➡️ 다음 주제:** {record['next_topic']}")
                        if record['previous_topic']:
                            st.write(f"**⬅️ 이전 주제:** {record['previous_topic']}")
                    
                    # 추가 프롬프트가 있다면 표시
                    if record['extra_prompt']:
                        st.write(f"**💡 추가 프롬프트:** {record['extra_prompt']}")
                    
                    # AI 생성 콘텐츠 표시
                    if record['ai_content']:
                        st.markdown("#### 📝 저장된 콘텐츠")
                        if record['content_type'] == 'summary':
                            # 요약의 경우 원본과 AI 요약을 구분하여 표시
                            content = record['ai_content']
                            if "=== 📝 원본 요약 파일 ===" in content and "=== 🤖 AI 생성 핵심 요약 ===" in content:
                                parts = content.split("=== 🤖 AI 생성 핵심 요약 ===")
                                if len(parts) == 2:
                                    original_content = parts[0].replace("=== 📝 원본 요약 파일 ===", "").strip()
                                    ai_content = parts[1].strip()
                                    
                                    # 탭으로 구분하여 표시
                                    sub_tab1, sub_tab2 = st.tabs(["📝 원본 요약", "🤖 AI 핵심 요약"])
                                    with sub_tab1:
                                        st.markdown(format_bullet_points(original_content))
                                    with sub_tab2:
                                        st.markdown(format_bullet_points(ai_content))
                                else:
                                    st.markdown(format_bullet_points(content))
                            else:
                                st.markdown(format_bullet_points(content))
                        elif record['content_type'] == 'application':
                            # 적용 파일의 경우 원본과 AI 요약을 구분하여 표시
                            content = record['ai_content']
                            if "=== 📝 원본 적용 파일 ===" in content and "=== 🤖 AI 요약 및 총평 ===" in content:
                                parts = content.split("=== 🤖 AI 요약 및 총평 ===")
                                if len(parts) == 2:
                                    original_content = parts[0].replace("=== 📝 원본 적용 파일 ===", "").strip()
                                    ai_content = parts[1].strip()
                                    
                                    # 탭으로 구분하여 표시
                                    sub_tab1, sub_tab2 = st.tabs(["📝 원본 적용 파일", "🤖 AI 요약 및 총평"])
                                    with sub_tab1:
                                        st.markdown(format_bullet_points(original_content))
                                    with sub_tab2:
                                        st.markdown(ai_content)
                                else:
                                    st.markdown(format_bullet_points(content))
                            else:
                                st.markdown(format_bullet_points(content))
                        else:
                            # 우화의 경우 그대로 표시
                            st.markdown(record['ai_content'])
                    
                    # 음성 재생 기능
                    if record['audio_data']:
                        st.markdown("#### 🎵 음성 재생")
                        try:
                            # BLOB 데이터를 base64로 변환하여 재생
                            audio_base64 = base64.b64encode(record['audio_data']).decode('utf-8')
                            audio_html = f'''
                                <audio controls style="width: 100%;">
                                    <source src="data:audio/mp3;base64,{audio_base64}" type="audio/mp3">
                                    Your browser does not support the audio element.
                                </audio>
                            '''
                            st.markdown(audio_html, unsafe_allow_html=True)
                            
                            # 다운로드 버튼
                            st.download_button(
                                label="🎵 음성 파일 다운로드",
                                data=record['audio_data'],
                                file_name=record['audio_filename'] or f"{record['content_type']}_{record['book_title']}_{record['id']}.mp3",
                                mime="audio/mp3",
                                key=f"download_audio_{record['id']}"
                            )
                        except Exception as e:
                            st.error(f"음성 재생 중 오류: {str(e)}")
                    else:
                        st.info("저장된 음성 파일이 없습니다.")
                    
                    # 요약 파일의 경우 Tiro 녹음기능 알림 추가 (삭제 메뉴 바로 위)
                    if record['content_type'] == 'summary':
                        st.markdown(
                            '''
                            <div style="background: linear-gradient(145deg, #0066cc, #0052a3); color: white; padding: 20px; border-radius: 15px; text-align: center; margin: 20px 0; font-size: 1.3rem; font-weight: bold;">
                                🎙️ Tiro 녹음기능을 활성화해 주세요!<br>
                                <span style="font-size: 1rem; font-weight: normal;">토론 내용 기록을 위해 꼭 필요합니다.<br>시작 전 반드시 확인해 주세요.</span>
                            </div>
                            ''',
                            unsafe_allow_html=True
                        )
                    
                    # 삭제 기능
                    st.markdown("#### 🗑️ 삭제")
                    col_delete1, col_delete2 = st.columns([3, 1])
                    with col_delete1:
                        st.warning("⚠️ 삭제하면 복구할 수 없습니다. 신중하게 결정해주세요.")
                    with col_delete2:
                        if st.button(
                            "🗑️ 삭제", 
                            key=f"delete_btn_{record['id']}", 
                            type="secondary",
                            help="이 기록을 영구 삭제합니다"
                        ):
                            # 세션 상태에 삭제 확인 요청 저장
                            st.session_state[f"confirm_delete_{record['id']}"] = True
                    
                    # 삭제 확인 단계
                    if st.session_state.get(f"confirm_delete_{record['id']}", False):
                        st.error("🚨 **정말로 이 기록을 삭제하시겠습니까?**")
                        col_confirm1, col_confirm2, col_confirm3 = st.columns([1, 1, 2])
                        with col_confirm1:
                            if st.button("✅ 예, 삭제", key=f"confirm_yes_{record['id']}", type="primary"):
                                if delete_reading_discussion_record(record['id']):
                                    st.success("기록이 성공적으로 삭제되었습니다.")
                                    # 삭제 확인 상태 초기화
                                    if f"confirm_delete_{record['id']}" in st.session_state:
                                        del st.session_state[f"confirm_delete_{record['id']}"]
                                    time.sleep(1)
                                    st.rerun()  # 페이지 새로고침으로 삭제된 항목 제거
                                else:
                                    st.error("삭제 중 오류가 발생했습니다.")
                        with col_confirm2:
                            if st.button("❌ 아니오, 취소", key=f"confirm_no_{record['id']}", type="secondary"):
                                # 삭제 확인 상태 초기화
                                if f"confirm_delete_{record['id']}" in st.session_state:
                                    del st.session_state[f"confirm_delete_{record['id']}"]
                                st.rerun()
                    
                    # 구분선
                    st.markdown("---")
        else:
            st.info("저장된 기록이 없습니다. AI 요약이나 우화를 생성하고 음성을 생성해보세요!")
        
        # 푸터
        st.markdown("---")
        st.markdown("""
        **💡 사용 팁:**
        - **탭 구분**: "AI 핵심 요약" 및 "AI 요약 및 총평" 탭의 내용이 실제 음성으로 변환된 텍스트입니다
        - **다운로드**: 각 음성 파일을 다운로드할 수 있습니다
        - **삭제 기능**: 개별 삭제 및 전체 삭제가 가능합니다
        - **최신순 정렬**: 가장 최근에 생성된 콘텐츠부터 표시됩니다
        """)
    
    with tab_order:
        discussion_order_tab()

def format_bullet_points(text):
    lines = text.split('\n')
    formatted = []
    
    for line in lines:
        line = line.strip()
        if not line:
            continue
            
        # *** 로 둘러싸인 제목 처리
        if line.startswith('***') and line.endswith('***'):
            title = line.replace('***', '').strip()
            formatted.append(f"**{title}**")
            continue
            
        # 일반 제목 처리 (굵게 처리할 조건들)
        if (line.startswith('#') or 
            line.startswith('**') or 
            (line and not line.startswith('•') and not line.startswith('-') and 
             not line.startswith('***') and len(line) < 100 and 
             not line.endswith('함') and not line.endswith('임'))):
            # 이미 **로 둘러싸여 있지 않은 경우에만 추가
            if not (line.startswith('**') and line.endswith('**')):
                formatted.append(f"**{line.replace('#','').strip()}**")
            else:
                formatted.append(line)
            continue
            
        # bullet point 처리
        if '•' in line:
            parts = line.split('•')
            new_line = parts[0]
            for part in parts[1:]:
                if part.strip():
                    new_line += '\n• ' + part.strip()
            formatted.append(new_line)
            continue
            
        # *** 로 둘러싸인 내용 처리 (제목이 아닌 경우)
        if '***' in line:
            # *** 제거하고 일반 텍스트로 처리
            clean_line = line.replace('***', '').strip()
            if clean_line:
                formatted.append(clean_line)
            continue
            
        # 일반 텍스트
        formatted.append(line)
    
    # 빈 줄 추가로 가독성 향상
    result = '\n\n'.join([l for l in formatted if l.strip()])
    
    # 마지막 정리: 연속된 빈 줄을 하나로 줄이기
    import re
    result = re.sub(r'\n{3,}', '\n\n', result)
    
    return result

def ai_summarize_keypoints(text, model_name, extra_prompt=None):
    summary_instruction = (
        "아래 텍스트에서 실제 비즈니스 업무 환경에 바로 적용할 수 있는 실전 핵심 내용 1~2가지만, 각 항목당 100자 이내의 bullet point(•)로 요약해 주세요. "
        "각 항목은 '~함' 형태의 한글로 작성하고, 존댓말은 사용하지 마세요. "
        "불필요한 설명 없이, 실무에서 바로 쓸 수 있는 구체적이고 실질적인 실천/적용 방안만 1~2개 bullet point로 제시해 주세요."
    )
    if model_name.startswith('claude'):
        client = ChatAnthropic(model=model_name, api_key=os.getenv('ANTHROPIC_API_KEY'), temperature=0.3, max_tokens=400)
        prompt = f"""
{summary_instruction}
---
{text}
"""
        if extra_prompt and extra_prompt.strip():
            prompt += f"\n[참고 내용]\n{extra_prompt.strip()}\n"
        response = client.invoke([
            {"role": "system", "content": "당신은 비즈니스 실전 적용 요약 전문가입니다. 항상 실제 업무에 바로 적용할 수 있는 실천/적용 방안만 1~2개, 각 항목당 100자 이내로 bullet point로 '~함' 형태의 간결체로 작성합니다. 존댓말은 사용하지 않습니다. 불필요한 설명은 제외합니다."},
            {"role": "user", "content": prompt}
        ])
        return response.content if hasattr(response, 'content') else str(response)
    else:
        # OpenAI API 키 검증
        openai_key = os.getenv('OPENAI_API_KEY')
        if not openai_key or openai_key.strip() == '' or openai_key == 'NA':
            raise ValueError(f"OpenAI API 키가 올바르지 않습니다. 현재 값: {openai_key}")
        
        try:
            client = OpenAI(api_key=openai_key)
            prompt = f"""
{summary_instruction}
---
{text}
"""
            if extra_prompt and extra_prompt.strip():
                prompt += f"\n[참고 내용]\n{extra_prompt.strip()}\n"
            response = client.chat.completions.create(
                model=model_name,
                messages=[
                    {"role": "system", "content": "당신은 비즈니스 실전 적용 요약 전문가입니다. 항상 실제 업무에 바로 적용할 수 있는 실천/적용 방안만 1~2개, 각 항목당 100자 이내로 bullet point로 '~함' 형태의 간결체로 작성합니다. 존댓말은 사용하지 않습니다. 불필요한 설명은 제외합니다."},
                    {"role": "user", "content": prompt}
                ],
                max_tokens=400,
                temperature=0.3
            )
            return response.choices[0].message.content
        except Exception as e:
            st.error(f"OpenAI API 호출 중 오류: {str(e)}")
            st.error(f"API 키 상태: {openai_key[:10] if openai_key else 'None'}... (길이: {len(openai_key) if openai_key else 0})")
            raise e

def ai_summarize_application_summary(text, model_name, extra_prompt=None):
    prompt = (
        "아래 적용 파일의 핵심 내용을 더 상세하게 요약해 주세요. 이어서, 총평의 제목은 반드시 '투명하고 진실한 조직 문화'로 하고, 그 아래에는 협업하는 조직 문화 만들기 관점에서 적용 파일에 대한 총평을 5줄 이내로 간결하게 작성해 주세요. 전체 분량은 약 2분 분량(요약은 상세하게, 총평은 간결하게)으로 해 주세요. 필요시 bullet point를 활용해도 좋습니다."
    )
    if model_name.startswith('claude'):
        client = ChatAnthropic(model=model_name, api_key=os.getenv('ANTHROPIC_API_KEY'), temperature=0.3, max_tokens=4096)
        prompt_full = f"{prompt}\n---\n{text}"
        if extra_prompt and extra_prompt.strip():
            prompt_full += f"\n[참고 내용]\n{extra_prompt.strip()}\n"
        response = client.invoke([
            {"role": "system", "content": "당신은 비즈니스 요약 및 평가 전문가입니다. 적용 파일의 핵심을 더 상세하게 요약하고, 총평의 제목은 반드시 '투명하고 진실한 조직 문화'로 하며, 그 아래에는 협업하는 조직 문화 만들기 관점에서 5줄 이내로 간결한 총평을 작성해 주세요."},
            {"role": "user", "content": prompt_full}
        ])
        return response.content if hasattr(response, 'content') else str(response)
    else:
        # OpenAI API 키 검증
        openai_key = os.getenv('OPENAI_API_KEY')
        if not openai_key or openai_key.strip() == '' or openai_key == 'NA':
            raise ValueError(f"OpenAI API 키가 올바르지 않습니다. 현재 값: {openai_key}")
        
        try:
            client = OpenAI(api_key=openai_key)
            prompt_full = f"{prompt}\n---\n{text}"
            if extra_prompt and extra_prompt.strip():
                prompt_full += f"\n[참고 내용]\n{extra_prompt.strip()}\n"
            response = client.chat.completions.create(
                model=model_name,
                messages=[
                    {"role": "system", "content": "당신은 비즈니스 요약 및 평가 전문가입니다. 적용 파일의 핵심을 더 상세하게 요약하고, 총평의 제목은 반드시 '투명하고 진실한 조직 문화'로 하며, 그 아래에는 협업하는 조직 문화 만들기 관점에서 5줄 이내로 간결한 총평을 작성해 주세요."},
                    {"role": "user", "content": prompt_full}
                ],
                max_tokens=4096,
                temperature=0.3
            )
            return response.choices[0].message.content
        except Exception as e:
            st.error(f"OpenAI API 호출 중 오류: {str(e)}")
            st.error(f"API 키 상태: {openai_key[:10] if openai_key else 'None'}... (길이: {len(openai_key) if openai_key else 0})")
            raise e

def is_pi_number_exists(pi_number):
    conn = connect_to_db()
    cursor = conn.cursor()
    cursor.execute("SELECT COUNT(*) FROM proforma_invoices WHERE pi_number = %s", (pi_number,))
    exists = cursor.fetchone()[0] > 0
    cursor.close()
    conn.close()
    return exists

if __name__ == "__main__":
    # 타이머 종료 음성 메시지 준비 (앱 시작 시 한 번만)
    if 'order_end_audio' not in st.session_state:
        try:
            from openai import OpenAI
            import base64, os
            
            # OpenAI API 키 검증
            openai_key = os.getenv('OPENAI_API_KEY')
            if openai_key and openai_key.strip() != '' and openai_key != 'NA':
                tts_text = "토론 시간이 종료되었습니다. 토론을 마무리해 주세요. 토론을 마무리해 주세요. 토론을 마무리해 주세요."
                client = OpenAI(api_key=openai_key)
                response = client.audio.speech.create(
                    model="tts-1",
                    voice="nova",
                    input=tts_text,
                    speed=0.9
                )
                audio_data = response.content
                audio_base64 = base64.b64encode(audio_data).decode('utf-8')
                st.session_state['order_end_audio'] = audio_base64
            else:
                print(f"[WARNING] OpenAI API 키가 올바르지 않아 타이머 종료 음성을 생성할 수 없습니다. 키 상태: {openai_key}")
                st.session_state['order_end_audio'] = ''
        except Exception as e:
            print(f"[ERROR] 타이머 종료 음성 생성 중 오류: {str(e)}")
            st.session_state['order_end_audio'] = ''
    
    # 핵심 보호된 상태들의 추가 백업 (앱 전체 실행 중 유지)
    protected_session_keys = ['ai_summary_result', 'tts_audio', 'ai_app_summary_result', 'tts_app_audio', 'ai_fable_result', 'tts_fable_audio']
    for key in protected_session_keys:
        # 영구 백업 생성 (앱 전체 실행 중 유지)
        if key in st.session_state and st.session_state[key] is not None:
            st.session_state[f"{key}_permanent_backup"] = st.session_state[key]
        # 영구 백업에서 복원 (값이 None이 되었을 때)
        elif f"{key}_permanent_backup" in st.session_state and st.session_state[f"{key}_permanent_backup"] is not None:
            st.session_state[key] = st.session_state[f"{key}_permanent_backup"]
    
    main() 