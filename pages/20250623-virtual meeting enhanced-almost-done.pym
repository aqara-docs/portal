import streamlit as st
from openai import OpenAI
import anthropic
import time
import threading
from datetime import datetime, timedelta
import json
import os
from typing import List, Dict, Any
import uuid
from dotenv import load_dotenv
import pandas as pd
from io import StringIO
import PyPDF2
import docx
import tempfile
from dataclasses import dataclass
import asyncio
import queue
import random
import mysql.connector

load_dotenv()

# 페이지 설정
st.set_page_config(
    page_title="Virtual Meeting Enhanced - AI 가상 회의",
    page_icon="🎭",
    layout="wide"
)

@dataclass
class Persona:
    id: str
    name: str
    role: str
    prompt: str
    personality: str
    expertise: str
    speaking_style: str
    is_moderator: bool = False
    
    def __post_init__(self):
        if not self.prompt:
            self.prompt = self.generate_default_prompt()
    
    def generate_default_prompt(self) -> str:
        return f"""당신은 {self.name}입니다. 
        역할: {self.role}
        전문 분야: {self.expertise}
        성격: {self.personality}
        말하는 스타일: {self.speaking_style}
        
        회의에서 당신의 전문성을 바탕으로 건설적인 의견을 제시하세요.
        다른 참가자들의 의견을 경청하고 존중하며, 토론을 발전시키는 방향으로 참여하세요."""

@dataclass
class Message:
    timestamp: datetime
    persona_id: str
    persona_name: str
    content: str
    is_human_input: bool = False
    is_moderator: bool = False

class VirtualMeeting:
    def __init__(self):
        self.personas: List[Persona] = []
        self.messages: List[Message] = []
        self.meeting_topic = ""
        self.meeting_duration = 30  # 분
        self.start_time = None
        self.is_active = False
        self.uploaded_files_content = ""
        self.current_speaker_index = 0
        self.conversation_round = 0
        self.max_rounds = 10
        self.auto_mode = False
        self.speaking_speed = 3  # 초
        self.last_message_time = None
        self.round_summaries: Dict[int, str] = {}  # 라운드별 요약 저장
        self.key_insights: List[str] = []  # 주요 인사이트 저장
        self.file_analysis: Dict[str, Any] = {}  # 업로드된 파일 분석 결과
        self.file_keywords: List[str] = []  # 파일에서 추출된 키워드
        self.typing_speed: float = 0.1  # 타이핑 효과 속도 (초)
        
    def add_persona(self, persona: Persona) -> bool:
        if len(self.personas) < 10:
            self.personas.append(persona)
            return True
        return False
    
    def remove_persona(self, persona_id: str):
        self.personas = [p for p in self.personas if p.id != persona_id]
    
    def get_moderator(self) -> Persona:
        for persona in self.personas:
            if persona.is_moderator:
                return persona
        return None
    
    def get_non_moderator_personas(self) -> List[Persona]:
        return [p for p in self.personas if not p.is_moderator]
    
    def add_message(self, persona_id: str, content: str, is_human_input: bool = False) -> Message:
        persona = next((p for p in self.personas if p.id == persona_id), None)
        if persona:
            message = Message(
                timestamp=datetime.now(),
                persona_id=persona_id,
                persona_name=persona.name,
                content=content,
                is_human_input=is_human_input,
                is_moderator=persona.is_moderator
            )
            self.messages.append(message)
            self.last_message_time = datetime.now()
            return message
        return None
    
    def get_next_speaker(self) -> Persona:
        non_moderator_personas = self.get_non_moderator_personas()
        if not non_moderator_personas:
            return None
        
        current_persona = non_moderator_personas[self.current_speaker_index % len(non_moderator_personas)]
        return current_persona
    
    def advance_speaker(self):
        non_moderator_personas = self.get_non_moderator_personas()
        if non_moderator_personas:
            self.current_speaker_index += 1
            if self.current_speaker_index % len(non_moderator_personas) == 0:
                self.conversation_round += 1
    
    def is_time_to_speak(self) -> bool:
        if not self.last_message_time:
            return True
        # total_seconds()를 사용하여 정확한 시간 계산
        time_diff = (datetime.now() - self.last_message_time).total_seconds()
        return time_diff >= self.speaking_speed
    
    def should_continue(self) -> bool:
        if not self.is_active:
            return False
        if self.conversation_round >= self.max_rounds:
            return False
        if self.start_time:
            elapsed_time = (datetime.now() - self.start_time).total_seconds()
            if elapsed_time > (self.meeting_duration * 60):
                return False
        return True
    
    def get_time_until_next_speak(self) -> float:
        """다음 발언까지 남은 시간 (초) 계산"""
        if not self.last_message_time:
            return 0.0
        elapsed = (datetime.now() - self.last_message_time).total_seconds()
        remaining = max(0.0, self.speaking_speed - elapsed)
        return remaining
        
    def generate_round_summary(self, round_number: int) -> str:
        """특정 라운드의 요약 생성"""
        if round_number in self.round_summaries:
            return self.round_summaries[round_number]
        
        # 해당 라운드의 메시지들 추출
        round_messages = []
        non_moderator_count = len(self.get_non_moderator_personas())
        
        if non_moderator_count == 0:
            return ""
        
        # 라운드별 메시지 범위 계산 (근사치)
        start_index = (round_number - 1) * non_moderator_count
        end_index = round_number * non_moderator_count
        
        for i, msg in enumerate(self.messages):
            if not msg.is_moderator and not msg.is_human_input:
                msg_round = (i // non_moderator_count) + 1
                if msg_round == round_number:
                    round_messages.append(msg)
        
        if not round_messages:
            return ""
        
        # 요약 생성
        summary_parts = []
        for msg in round_messages:
            persona = next((p for p in self.personas if p.id == msg.persona_id), None)
            if persona:
                summary_parts.append(f"{persona.role} {persona.name}: {msg.content[:80]}{'...' if len(msg.content) > 80 else ''}")
        
        summary = f"라운드 {round_number} 요약:\n" + "\n".join(summary_parts)
        self.round_summaries[round_number] = summary
        return summary
    
    def extract_key_insights(self) -> List[str]:
        """회의에서 핵심 인사이트 추출"""
        insights = []
        
        # 긴 메시지들에서 인사이트 추출 (100자 이상)
        for msg in self.messages:
            if len(msg.content) > 100 and not msg.is_moderator:
                persona = next((p for p in self.personas if p.id == msg.persona_id), None)
                if persona:
                    insight = f"[{persona.role}] {msg.content[:150]}{'...' if len(msg.content) > 150 else ''}"
                    insights.append(insight)
        
        self.key_insights = insights[-10:]  # 최근 10개만 유지
        return self.key_insights

    def analyze_uploaded_files(self) -> Dict[str, Any]:
        """업로드된 파일 내용을 분석하여 키워드와 요약 추출"""
        if not self.uploaded_files_content or self.file_analysis:
            return self.file_analysis
        
        try:
            # 간단한 키워드 추출 (공백과 줄바꿈으로 단어 분리)
            words = self.uploaded_files_content.replace('\n', ' ').split()
            # 길이가 3자 이상인 단어들만 추출 (한국어/영어 혼합 고려)
            meaningful_words = [word.strip('.,!?:;"()[]{}') for word in words 
                              if len(word.strip('.,!?:;"()[]{}')) >= 3]
            
            # 빈도 계산 (간단한 방식)
            word_count = {}
            for word in meaningful_words:
                word_lower = word.lower()
                word_count[word_lower] = word_count.get(word_lower, 0) + 1
            
            # 상위 키워드 추출 (빈도 기준)
            sorted_words = sorted(word_count.items(), key=lambda x: x[1], reverse=True)
            self.file_keywords = [word for word, count in sorted_words[:20] if count > 1]
            
            # 파일 요약 (첫 부분과 마지막 부분)
            content_length = len(self.uploaded_files_content)
            if content_length > 1000:
                summary = (self.uploaded_files_content[:500] + 
                          "\n...[중간 내용 생략]...\n" + 
                          self.uploaded_files_content[-300:])
            else:
                summary = self.uploaded_files_content
            
            self.file_analysis = {
                'keywords': self.file_keywords,
                'summary': summary,
                'total_length': content_length,
                'word_count': len(meaningful_words),
                'sections': self._extract_file_sections()
            }
            
        except Exception as e:
            self.file_analysis = {
                'error': f"파일 분석 오류: {str(e)}",
                'keywords': [],
                'summary': self.uploaded_files_content[:500] + "..." if len(self.uploaded_files_content) > 500 else self.uploaded_files_content
            }
        
        return self.file_analysis
    
    def _extract_file_sections(self) -> List[Dict[str, str]]:
        """파일에서 섹션별로 내용 분리"""
        sections = []
        if not self.uploaded_files_content:
            return sections
        
        # 파일명으로 구분된 섹션들 추출
        file_parts = self.uploaded_files_content.split('---')
        for i, part in enumerate(file_parts):
            if part.strip():
                lines = part.strip().split('\n')
                if len(lines) > 1:
                    # 첫 줄이 파일명인 경우
                    title = lines[0].strip() if len(lines[0].strip()) < 100 else f"섹션 {i+1}"
                    content = '\n'.join(lines[1:]).strip()
                    if content:
                        sections.append({
                            'title': title,
                            'content': content[:800] + "..." if len(content) > 800 else content
                        })
        
        return sections
    
    def get_relevant_file_content(self, query_keywords: List[str]) -> str:
        """쿼리 키워드와 관련된 파일 내용 추출 (간단한 RAG)"""
        if not self.uploaded_files_content:
            return ""
        
        analysis = self.analyze_uploaded_files()
        
        # 키워드 매칭을 통한 관련 섹션 추출
        relevant_sections = []
        
        for section in analysis.get('sections', []):
            content_lower = section['content'].lower()
            # 쿼리 키워드 중 하나라도 포함된 섹션 추출
            for keyword in query_keywords:
                if keyword.lower() in content_lower:
                    relevant_sections.append(section)
                    break
        
        if relevant_sections:
            result = "=== 관련 참고 자료 ===\n"
            for section in relevant_sections[:3]:  # 최대 3개 섹션만
                result += f"\n📄 {section['title']}\n{section['content']}\n"
            return result
        else:
            # 관련 섹션이 없으면 전체 요약 반환
            return f"=== 참고 자료 요약 ===\n{analysis.get('summary', '')}"

def initialize_session_state():
    """세션 상태 초기화"""
    if 'virtual_meeting' not in st.session_state:
        st.session_state.virtual_meeting = VirtualMeeting()
    
    # AI 모델 선택 초기화
    if 'selected_ai_model' not in st.session_state:
        st.session_state.selected_ai_model = 'gpt-4o-mini'
        
        # 기본 사회자 페르소나 생성
        moderator = Persona(
            id="moderator_001",
            name="사회자 김진행",
            role="회의 사회자",
            prompt="""당신은 전문적인 회의 사회자입니다. 
            회의의 흐름을 원활하게 이끌고, 참가자들의 의견을 적절히 조율하며, 
            주제에서 벗어나지 않도록 안내하는 역할을 합니다.
            간결하고 명확하게 말하며, 모든 참가자가 발언할 기회를 갖도록 합니다.
            
            회의 진행 시 다음과 같은 역할을 수행합니다:
            - 회의 시작 시 참가자 소개 및 주제 안내
            - 발언 순서 조정 및 시간 관리
            - 토론이 격화되거나 주제에서 벗어날 때 중재
            - 중간 정리 및 결론 도출
            
            말하는 스타일: 정중하고 명확하며 간결하게, 때로는 유머를 섞어 분위기를 부드럽게 만듭니다.""",
            personality="차분하고 공정하며 전문적, 적절한 유머 감각",
            expertise="회의 진행, 토론 조율, 의견 정리, 갈등 중재",
            speaking_style="정중하고 명확하며 간결한 말투, 때로는 친근한 농담",
            is_moderator=True
        )
        st.session_state.virtual_meeting.add_persona(moderator)
    
    # 자동 모드 관련 세션 상태 추가
    if 'auto_mode_last_run' not in st.session_state:
        st.session_state.auto_mode_last_run = datetime.now()
    
    if 'auto_mode_running' not in st.session_state:
        st.session_state.auto_mode_running = False
    
    # 기본 페르소나들 추가 (예시)
    if len(st.session_state.virtual_meeting.personas) == 1:  # 사회자만 있는 경우
        sample_personas = [
            Persona(
                id="ceo_001",
                name="CEO 박성공",
                role="최고경영자",
                prompt="",
                personality="비전을 제시하고 리더십을 발휘하는 성격",
                expertise="전략 경영, 의사결정, 리더십",
                speaking_style="확신에 차고 카리스마 있는 말투"
            ),
            Persona(
                id="cto_001", 
                name="CTO 이기술",
                role="최고기술책임자",
                prompt="",
                personality="논리적이고 분석적인 성격",
                expertise="기술 전략, 개발, 혁신",
                speaking_style="데이터와 근거를 바탕으로 한 차분한 말투"
            ),
            Persona(
                id="cmo_001",
                name="CMO 김마케팅",
                role="최고마케팅책임자", 
                prompt="",
                personality="창의적이고 소통을 중시하는 성격",
                expertise="마케팅 전략, 브랜딩, 고객 분석",
                speaking_style="열정적이고 창의적인 아이디어를 제시하는 말투"
            )
        ]
        
        for persona in sample_personas:
            st.session_state.virtual_meeting.add_persona(persona)

def connect_to_db():
    """데이터베이스 연결"""
    try:
        conn = mysql.connector.connect(
            host=os.getenv('SQL_HOST'),
            user=os.getenv('SQL_USER'),
            password=os.getenv('SQL_PASSWORD'),
            database=os.getenv('SQL_DATABASE_NEWBIZ'),
            charset='utf8mb4',
            collation='utf8mb4_unicode_ci'
        )
        return conn
    except mysql.connector.Error as err:
        st.error(f"데이터베이스 연결 오류: {err}")
        return None

def save_meeting_record(meeting: 'VirtualMeeting', meeting_log: str, summary: str) -> bool:
    """회의록을 데이터베이스에 저장"""
    try:
        conn = connect_to_db()
        if not conn:
            return False
        
        cursor = conn.cursor()
        
        # 참가자 목록 생성
        participants = ", ".join([p.name + "(" + p.role + ")" for p in meeting.personas])
        
        # 사용된 AI 모델 정보 추가
        ai_model_used = st.session_state.get('selected_ai_model', 'gpt-4o-mini')
        
        # 회의록 저장 (action_items 필드에 AI 모델 정보 임시 저장)
        cursor.execute("""
            INSERT INTO meeting_records 
            (title, date, participants, full_text, summary, action_items, created_at)
            VALUES (%s, %s, %s, %s, %s, %s, %s)
        """, (
            meeting.meeting_topic,
            meeting.start_time if meeting.start_time else datetime.now(),
            participants,
            meeting_log,
            summary,
            f"AI 모델: {ai_model_used}",  # action_items 필드에 AI 모델 정보 저장
            datetime.now()
        ))
        
        conn.commit()
        cursor.close()
        conn.close()
        return True
        
    except mysql.connector.Error as err:
        st.error(f"회의록 저장 오류: {err}")
        return False

def get_saved_meeting_records() -> List[Dict]:
    """저장된 회의록 목록 조회"""
    try:
        conn = connect_to_db()
        if not conn:
            return []
        
        cursor = conn.cursor()
        cursor.execute("""
            SELECT meeting_id, title, date, participants, created_at
            FROM meeting_records
            ORDER BY date DESC, created_at DESC
        """)
        
        records = []
        for row in cursor.fetchall():
            records.append({
                'meeting_id': row[0],
                'title': row[1],
                'date': row[2],
                'participants': row[3],
                'created_at': row[4]
            })
        
        cursor.close()
        conn.close()
        return records
        
    except mysql.connector.Error as err:
        st.error(f"회의록 조회 오류: {err}")
        return []

def get_meeting_record_detail(meeting_id: int) -> Dict:
    """특정 회의록 상세 조회"""
    try:
        conn = connect_to_db()
        if not conn:
            return {}
        
        cursor = conn.cursor()
        cursor.execute("""
            SELECT meeting_id, title, date, participants, full_text, summary, action_items, created_at
            FROM meeting_records
            WHERE meeting_id = %s
        """, (meeting_id,))
        
        row = cursor.fetchone()
        if row:
            record = {
                'meeting_id': row[0],
                'title': row[1],
                'date': row[2],
                'participants': row[3],
                'full_text': row[4],
                'summary': row[5],
                'action_items': row[6],
                'created_at': row[7]
            }
        else:
            record = {}
        
        cursor.close()
        conn.close()
        return record
        
    except mysql.connector.Error as err:
        st.error(f"회의록 상세 조회 오류: {err}")
        return {}

def delete_meeting_record(meeting_id: int) -> bool:
    """회의록 삭제"""
    try:
        conn = connect_to_db()
        if not conn:
            return False
        
        cursor = conn.cursor()
        cursor.execute("DELETE FROM meeting_records WHERE meeting_id = %s", (meeting_id,))
        
        conn.commit()
        cursor.close()
        conn.close()
        return True
        
    except mysql.connector.Error as err:
        st.error(f"회의록 삭제 오류: {err}")
        return False

def generate_meeting_summary(meeting_log: str, model_name: str = "gpt-4o-mini") -> str:
    """AI를 사용하여 회의록 요약 생성"""
    try:
        # 모델에 따른 클라이언트 설정
        if model_name.startswith('claude'):
            # Anthropic Claude 모델
            anthropic_key = os.getenv('ANTHROPIC_API_KEY')
            if not anthropic_key or anthropic_key.strip() == '' or anthropic_key == 'NA':
                return "AI 요약을 생성할 수 없습니다. Anthropic API 키를 확인해주세요."
            
            client = anthropic.Anthropic(api_key=anthropic_key)
        else:
            # OpenAI 모델
            openai_key = os.getenv('OPENAI_API_KEY')
            if not openai_key or openai_key.strip() == '' or openai_key == 'NA':
                return "AI 요약을 생성할 수 없습니다. OpenAI API 키를 확인해주세요."
            
            client = OpenAI(api_key=openai_key)
        
        system_prompt = """당신은 회의록 요약 전문가입니다. 주어진 회의 내용을 바탕으로 다음 형식으로 요약해주세요:

## 📋 회의 요약

### 🎯 주요 논의 사항
- 핵심 논의 포인트들을 3-5개 정도로 정리

### 💡 주요 의견 및 제안
- 참가자별 주요 의견과 제안사항

### ✅ 결론 및 합의사항
- 회의를 통해 도출된 결론이나 합의된 내용

### 📝 향후 액션 아이템
- 후속 조치가 필요한 사항들

### 🔍 추가 검토 필요 사항
- 추후 논의가 필요한 이슈들

간결하고 명확하게 작성하되, 중요한 내용은 빠뜨리지 말고 포함해주세요."""

        user_message = f"다음 회의 내용을 요약해주세요:\n\n{meeting_log}"
        
        if model_name.startswith('claude'):
            # Claude API 호출
            response = client.messages.create(
                model=model_name,
                max_tokens=1000,
                temperature=0.3,
                system=system_prompt,
                messages=[
                    {"role": "user", "content": user_message}
                ]
            )
            return response.content[0].text.strip()
        else:
            # OpenAI API 호출
            response = client.chat.completions.create(
                model=model_name,
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": user_message}
                ],
                max_tokens=1000,
                temperature=0.3
            )
            return response.choices[0].message.content.strip()
        
    except Exception as e:
        return f"요약 생성 중 오류가 발생했습니다: {str(e)}"

def extract_text_from_file(uploaded_file) -> str:
    """업로드된 파일에서 텍스트 추출"""
    try:
        file_type = uploaded_file.type
        content = ""
        
        if file_type == "text/plain":
            content = str(uploaded_file.read(), "utf-8")
        elif file_type == "application/pdf":
            pdf_reader = PyPDF2.PdfReader(uploaded_file)
            for page in pdf_reader.pages:
                content += page.extract_text()
        elif file_type == "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
            doc = docx.Document(uploaded_file)
            for paragraph in doc.paragraphs:
                content += paragraph.text + "\n"
        elif file_type == "text/csv":
            df = pd.read_csv(uploaded_file)
            content = df.to_string()
        else:
            content = "지원하지 않는 파일 형식입니다."
            
        return content
    except Exception as e:
        return f"파일 읽기 오류: {str(e)}"

def generate_ai_response(persona: Persona, conversation_history: str, meeting_topic: str, file_content: str, round_number: int, enhanced_context: str = "", model_name: str = "gpt-4o-mini") -> str:
    """AI 응답 생성 - 라운드별 맥락 유지 강화"""
    try:
        # 모델에 따른 클라이언트 설정
        if model_name.startswith('claude'):
            # Anthropic Claude 모델
            anthropic_key = os.getenv('ANTHROPIC_API_KEY')
            if not anthropic_key or anthropic_key.strip() == '' or anthropic_key == 'NA':
                raise ValueError("Anthropic API 키가 올바르지 않습니다. .env 파일에서 ANTHROPIC_API_KEY를 확인해주세요.")
            
            client = anthropic.Anthropic(api_key=anthropic_key)
        else:
            # OpenAI 모델
            openai_key = os.getenv('OPENAI_API_KEY')
            if not openai_key or openai_key.strip() == '' or openai_key == 'NA':
                raise ValueError("OpenAI API 키가 올바르지 않습니다. .env 파일에서 OPENAI_API_KEY를 확인해주세요.")
            
            client = OpenAI(api_key=openai_key)
        
        # 라운드에 따른 맥락 조정
        round_context = ""
        if round_number == 1:
            round_context = "이번이 첫 번째 발언입니다. 자신을 한 문장으로 간단히 소개한 후 주제에 대한 의견을 제시하세요."
        elif round_number <= 3:
            round_context = "회의가 진행 중입니다. 이전 라운드의 논의를 참고하여 자신의 관점을 추가하세요. 자기소개는 하지 마세요."
        elif round_number <= 6:
            round_context = "토론이 깊어지고 있습니다. 지금까지의 논의를 바탕으로 구체적인 해결책이나 대안을 제시해보세요. 자기소개는 하지 마세요."
        else:
            round_context = "토론이 마무리 단계입니다. 전체 회의 내용을 종합하여 결론을 향해 나아가는 의견을 제시하세요. 자기소개는 하지 마세요."
        
        system_prompt = f"""
        {persona.prompt}
        
        당신의 정보:
        - 이름: {persona.name}
        - 역할: {persona.role}
        - 성격: {persona.personality}
        - 전문 분야: {persona.expertise}
        - 말하는 스타일: {persona.speaking_style}
        
        {round_context}
        
        중요한 지침:
        - 이전 라운드들의 논의 맥락을 고려하여 발언하세요
        - 첫 번째 라운드가 아니라면 자기소개를 하지 마세요
        - 다른 참가자들의 의견을 참고하고 언급하여 연속성을 만드세요
        - 자연스럽고 사람다운 말투로 2-3문장 정도로 작성해주세요
        - 회의 전체 흐름을 고려한 건설적인 의견을 제시하세요
        - 제공된 참고 자료가 있다면 반드시 그 내용을 바탕으로 구체적인 데이터나 사실을 언급하세요
        - 참고 자료의 정보를 자신의 전문성과 연결하여 해석하고 활용하세요
        """
        
        # 개선된 맥락 사용 (enhanced_context가 있으면 우선 사용)
        context_to_use = enhanced_context if enhanced_context else conversation_history
        
        user_message = f"회의 전체 맥락:\n{context_to_use}\n\n위 맥락을 바탕으로 '{meeting_topic}' 주제에 대해 라운드 {round_number}에서 발언해주세요."
        
        if model_name.startswith('claude'):
            # Claude API 호출
            response = client.messages.create(
                model=model_name,
                max_tokens=400,
                temperature=0.8,
                system=system_prompt,
                messages=[
                    {"role": "user", "content": user_message}
                ]
            )
            return response.content[0].text.strip()
        else:
            # OpenAI API 호출
            response = client.chat.completions.create(
                model=model_name,
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": user_message}
                ],
                max_tokens=400,
                temperature=0.8
            )
            return response.choices[0].message.content.strip()
    except Exception as e:
        return f"[AI 응답 생성 오류: {str(e)}]"

def format_conversation_history(messages: List[Message], last_n: int = 15) -> str:
    """대화 히스토리 포맷팅 - 기본 버전 (하위 호환성 유지)"""
    recent_messages = messages[-last_n:] if len(messages) > last_n else messages
    history = ""
    for msg in recent_messages:
        history += f"{msg.persona_name}: {msg.content}\n"
    return history

def get_round_based_context(messages: List[Message], current_round: int, max_context_length: int = 2000) -> str:
    """라운드 기반 맥락 생성 - 전체 회의 맥락 유지"""
    if not messages:
        return ""
    
    # 라운드별 메시지 그룹화
    rounds_data = {}
    moderator_messages = []
    current_round_msgs = []
    
    for msg in messages:
        if msg.is_moderator:
            moderator_messages.append(msg)
        else:
            # 비사회자 메시지로 라운드 추정 (간단한 방식)
            estimated_round = len([m for m in messages[:messages.index(msg)+1] 
                                 if not m.is_moderator and not m.is_human_input]) // len([p for p in messages[0:1] if messages]) + 1
            
            if estimated_round not in rounds_data:
                rounds_data[estimated_round] = []
            rounds_data[estimated_round].append(msg)
    
    # 맥락 구성 전략
    context_parts = []
    
    # 1. 사회자 오프닝 (항상 포함)
    if moderator_messages:
        context_parts.append(f"[회의 시작] {moderator_messages[0].persona_name}: {moderator_messages[0].content}")
    
    # 2. 이전 라운드 요약 (라운드 2 이상일 때)
    if current_round > 1:
        previous_rounds_summary = []
        for round_num in sorted(rounds_data.keys()):
            if round_num < current_round:
                round_messages = rounds_data[round_num]
                if round_messages:
                    # 각 라운드의 핵심 포인트만 요약
                    key_points = []
                    for msg in round_messages:
                        # 메시지 길이가 긴 경우 요약
                        content = msg.content[:100] + "..." if len(msg.content) > 100 else msg.content
                        key_points.append(f"{msg.persona_name}: {content}")
                    
                    previous_rounds_summary.append(f"\n[라운드 {round_num}]\n" + "\n".join(key_points))
        
        if previous_rounds_summary:
            context_parts.append("=== 이전 라운드 요약 ===")
            context_parts.extend(previous_rounds_summary)
    
    # 3. 최근 메시지들 (항상 포함 - 직접적 맥락)
    recent_messages = messages[-8:]  # 최근 8개 메시지
    if recent_messages:
        context_parts.append("\n=== 최근 대화 ===")
        for msg in recent_messages:
            context_parts.append(f"{msg.persona_name}: {msg.content}")
    
    # 4. 현재 라운드 진행 상황
    context_parts.append(f"\n=== 현재 상황 ===")
    context_parts.append(f"현재 라운드: {current_round}")
    
    # 전체 맥락 조합
    full_context = "\n".join(context_parts)
    
    # 토큰 길이 제한 (대략적으로 문자 수로 제한)
    if len(full_context) > max_context_length:
        # 길이가 초과되면 이전 라운드 요약 부분을 더 압축
        essential_parts = []
        
        # 필수 요소: 오프닝 + 최근 대화 + 현재 상황
        if moderator_messages:
            essential_parts.append(f"[회의 시작] {moderator_messages[0].persona_name}: {moderator_messages[0].content}")
        
        essential_parts.append("\n=== 최근 대화 ===")
        for msg in recent_messages:
            essential_parts.append(f"{msg.persona_name}: {msg.content}")
        
        essential_parts.append(f"\n=== 현재 상황 ===")
        essential_parts.append(f"현재 라운드: {current_round}")
        
        # 남은 공간에 이전 라운드 핵심만 추가
        essential_context = "\n".join(essential_parts)
        remaining_space = max_context_length - len(essential_context)
        
        if remaining_space > 200 and current_round > 1:
            # 가장 최근 1-2 라운드만 간략하게 추가
            recent_rounds = []
            for round_num in sorted(rounds_data.keys(), reverse=True):
                if round_num < current_round and len(recent_rounds) < 2:
                    round_messages = rounds_data[round_num][:3]  # 라운드당 최대 3개 메시지만
                    if round_messages:
                        round_summary = f"[라운드 {round_num}] " + "; ".join([f"{msg.persona_name}: {msg.content[:50]}..." for msg in round_messages])
                        if len(round_summary) < remaining_space:
                            recent_rounds.append(round_summary)
                            remaining_space -= len(round_summary)
            
            if recent_rounds:
                essential_parts.insert(-2, "\n=== 주요 라운드 요약 ===")
                essential_parts.insert(-2, "\n".join(reversed(recent_rounds)))
        
        full_context = "\n".join(essential_parts)
    
    return full_context

def get_comprehensive_meeting_context(meeting: 'VirtualMeeting') -> str:
    """회의 전체 맥락을 종합적으로 생성 - RAG 강화 버전"""
    context_parts = []
    
    # 회의 기본 정보
    context_parts.append(f"=== 회의 정보 ===")
    context_parts.append(f"주제: {meeting.meeting_topic}")
    context_parts.append(f"현재 라운드: {meeting.conversation_round + 1}/{meeting.max_rounds}")
    context_parts.append(f"참여자: {', '.join([p.name + '(' + p.role + ')' for p in meeting.personas])}")
    
    # 업로드된 파일 내용 (스마트 활용)
    if meeting.uploaded_files_content:
        # 회의 주제와 관련된 키워드 추출
        topic_keywords = meeting.meeting_topic.replace(',', ' ').replace('.', ' ').split()
        topic_keywords = [k.strip() for k in topic_keywords if len(k.strip()) >= 2]
        
        # 관련 파일 내용 추출 (RAG 방식)
        relevant_content = meeting.get_relevant_file_content(topic_keywords)
        if relevant_content:
            context_parts.append(f"\n{relevant_content}")
        
        # 파일 분석 정보 추가
        file_analysis = meeting.analyze_uploaded_files()
        if file_analysis.get('keywords'):
            context_parts.append(f"\n=== 파일 키워드 ===")
            context_parts.append(f"핵심 키워드: {', '.join(file_analysis['keywords'][:10])}")
            context_parts.append(f"문서 정보: {file_analysis.get('word_count', 0):,}단어, {file_analysis.get('total_length', 0):,}자")
    
    # 완료된 라운드 요약들 (RAG 핵심 부분)
    if meeting.conversation_round > 0:
        context_parts.append(f"\n=== 완료된 라운드 요약 ===")
        for round_num in range(1, meeting.conversation_round + 1):
            summary = meeting.generate_round_summary(round_num)
            if summary:
                context_parts.append(summary)
    
    # 핵심 인사이트 (RAG 강화)
    key_insights = meeting.extract_key_insights()
    if key_insights:
        context_parts.append(f"\n=== 핵심 인사이트 ===")
        for insight in key_insights[-5:]:  # 최근 5개만
            context_parts.append(f"• {insight}")
    
    # 최근 대화 (직접적 맥락)
    recent_messages = meeting.messages[-6:] if len(meeting.messages) > 6 else meeting.messages
    if recent_messages:
        context_parts.append(f"\n=== 최근 대화 ===")
        for msg in recent_messages:
            context_parts.append(f"{msg.persona_name}: {msg.content}")
    
    # 다음 라운드 방향성 제시
    context_parts.append(f"\n=== 다음 발언 방향 ===")
    if meeting.conversation_round + 1 <= 3:
        context_parts.append("초기 의견 개진 및 문제 정의 단계")
    elif meeting.conversation_round + 1 <= 6:
        context_parts.append("심화 토론 및 해결책 모색 단계")
    else:
        context_parts.append("결론 도출 및 실행 방안 정리 단계")
    
    return "\n".join(context_parts)

def stream_response(text: str, typing_speed: float = 0.1):
    """스트리밍 타이핑 효과 - 속도 조절 가능"""
    import time
    words = text.split()
    for i, word in enumerate(words):
        if i == 0:
            yield word
        else:
            yield " " + word
        time.sleep(typing_speed)  # 타이핑 속도 조절 (사용자 설정)

def display_message(message: Message, is_latest: bool = False):
    """메시지 표시"""
    avatar = "🎯" if message.is_moderator else "🎭"
    if message.is_human_input:
        avatar = "👤"
    
    with st.chat_message(
        "assistant" if not message.is_human_input else "human",
        avatar=avatar
    ):
        col1, col2 = st.columns([3, 1])
        with col1:
            st.write(f"**{message.persona_name}**")
            # 최신 메시지만 타이핑 효과 적용
            if is_latest and not message.is_human_input:
                # 세션 상태에서 타이핑 속도 가져오기
                meeting = st.session_state.virtual_meeting
                st.write_stream(stream_response(message.content, meeting.typing_speed))
            else:
                st.write(message.content)
        with col2:
            st.caption(message.timestamp.strftime('%H:%M:%S'))
            if message.is_human_input:
                st.caption("👤 인간 개입")

def run_conversation_round(meeting: VirtualMeeting) -> bool:
    """한 라운드의 대화 실행 - 라운드별 맥락 유지 강화"""
    if not meeting.should_continue():
        return False
    
    current_persona = meeting.get_next_speaker()
    if not current_persona:
        return False
    
    # 기존 대화 히스토리 (하위 호환성)
    conversation_history = format_conversation_history(meeting.messages)
    
    # 개선된 전체 회의 맥락 생성
    comprehensive_context = get_comprehensive_meeting_context(meeting)
    
    # AI 응답 생성 (개선된 맥락 사용)
    selected_model = st.session_state.get('selected_ai_model', 'gpt-4o-mini')
    response = generate_ai_response(
        current_persona,
        conversation_history,  # 기본 히스토리 (fallback용)
        meeting.meeting_topic,
        meeting.uploaded_files_content,
        meeting.conversation_round + 1,
        enhanced_context=comprehensive_context,  # 라운드별 맥락이 포함된 종합 맥락
        model_name=selected_model
    )
    
    # 메시지 추가
    meeting.add_message(current_persona.id, response)
    
    # 다음 발언자로 이동
    meeting.advance_speaker()
    
    return True

def preset_personas() -> List[Dict]:
    """미리 설정된 페르소나 목록"""
    return [
        {
            "name": "전략기획자 이전략",
            "role": "전략기획팀장",
            "personality": "분석적이고 체계적인 사고를 하는 성격",
            "expertise": "전략 수립, 사업 분석, 시장 조사",
            "speaking_style": "논리적이고 체계적인 설명을 하는 말투"
        },
        {
            "name": "디자이너 박창의",
            "role": "UX/UI 디자이너",
            "personality": "창의적이고 사용자 중심적 사고를 하는 성격",
            "expertise": "사용자 경험, 인터페이스 디자인, 디자인 시스템",
            "speaking_style": "감성적이고 직관적인 표현을 사용하는 말투"
        },
        {
            "name": "개발자 김코딩",
            "role": "시니어 개발자",
            "personality": "논리적이고 문제 해결 지향적인 성격",
            "expertise": "소프트웨어 개발, 시스템 아키텍처, 기술 최적화",
            "speaking_style": "간결하고 기술적인 용어를 사용하는 말투"
        },
        {
            "name": "영업팀장 최세일즈",
            "role": "영업팀장",
            "personality": "적극적이고 목표 지향적인 성격",
            "expertise": "고객 관리, 영업 전략, 협상",
            "speaking_style": "열정적이고 설득력 있는 말투"
        },
        {
            "name": "재무담당자 정캐시",
            "role": "재무팀장",
            "personality": "신중하고 정확성을 중시하는 성격",
            "expertise": "재무 분석, 예산 관리, 투자 평가",
            "speaking_style": "정확한 수치와 데이터를 기반으로 한 신중한 말투"
        }
    ]

def main():
    st.title("🎭 Virtual Meeting Enhanced - AI 가상 회의")
    
    # 세션 상태 초기화
    initialize_session_state()
    meeting = st.session_state.virtual_meeting
    
    # 사이드바 - 회의 설정
    with st.sidebar:
        st.header("🎯 회의 설정")
        
        # AI 모델 선택 (독서토론과 동일한 방식)
        st.subheader("🤖 AI 모델 설정")
        
        # 사용 가능한 모델 목록 생성
        available_models = []
        has_anthropic_key = os.environ.get('ANTHROPIC_API_KEY') is not None
        if has_anthropic_key:
            available_models.extend([
                'claude-3-5-sonnet-latest',
                'claude-3-5-haiku-latest',
            ])
        has_openai_key = os.environ.get('OPENAI_API_KEY') is not None
        if has_openai_key:
            available_models.extend(['gpt-4o', 'gpt-4o-mini'])
        
        # 모델이 하나도 없으면 기본값 추가
        if not available_models:
            available_models = ['gpt-4o-mini']
        
        # 현재 선택된 모델이 사용 가능한 목록에 있는지 확인
        current_model = st.session_state.get('selected_ai_model', 'gpt-4o-mini')
        if current_model not in available_models and available_models:
            current_model = available_models[0]
            st.session_state.selected_ai_model = current_model
        
        # 모델 선택 UI
        selected_model = st.selectbox(
            '🧠 AI 모델 선택',
            options=available_models,
            index=available_models.index(current_model) if current_model in available_models else 0,
            help='Claude(Anthropic)는 ANTHROPIC_API_KEY, OpenAI는 OPENAI_API_KEY 필요'
        )
        
        # 모델이 실제로 변경된 경우에만 세션 상태 업데이트
        if selected_model != st.session_state.get('selected_ai_model'):
            st.session_state.selected_ai_model = selected_model
        
        # 선택된 모델 정보 표시
        if selected_model.startswith('claude'):
            st.info("🧠 **Claude 모델 사용 중**\n- 고품질 대화 생성\n- 긴 맥락 이해 우수")
        else:
            st.info("🧠 **OpenAI 모델 사용 중**\n- 빠른 응답 속도\n- 안정적인 성능")
        
        st.divider()
        
        # 회의 주제
        meeting.meeting_topic = st.text_area(
            "회의 주제",
            value=meeting.meeting_topic,
            help="토론할 주제를 입력하세요",
            placeholder="예: 신제품 출시 전략 수립"
        )
        
        # 회의 시간 설정
        meeting.meeting_duration = st.slider(
            "회의 시간 (분)",
            min_value=5,
            max_value=120,
            value=meeting.meeting_duration
        )
        
        # 최대 라운드 설정
        meeting.max_rounds = st.slider(
            "최대 대화 라운드",
            min_value=3,
            max_value=20,
            value=meeting.max_rounds
        )
        
        # 발언 속도 설정
        meeting.speaking_speed = st.slider(
            "발언 간격 (초)",
            min_value=1,
            max_value=10,
            value=meeting.speaking_speed,
            help="자동 모드에서 발언 간격을 조절합니다"
        )
        
        # 타이핑 속도 설정 (새로 추가)
        st.subheader("⌨️ 화면 표시 설정")
        
        # 타이핑 속도 옵션
        typing_options = {
            "매우 빠름 (0.02초)": 0.02,
            "빠름 (0.05초)": 0.05,
            "보통 (0.1초)": 0.1,
            "느림 (0.15초)": 0.15,
            "매우 느림 (0.25초)": 0.25,
            "커스텀": "custom"
        }
        
        # 현재 설정된 값에 맞는 옵션 찾기
        current_option = "보통 (0.1초)"  # 기본값
        for option, value in typing_options.items():
            if value == meeting.typing_speed:
                current_option = option
                break
        
        selected_option = st.selectbox(
            "💬 텍스트 타이핑 속도",
            options=list(typing_options.keys()),
            index=list(typing_options.keys()).index(current_option),
            help="AI 발언이 화면에 타이핑되어 나오는 속도를 조절합니다"
        )
        
        if typing_options[selected_option] == "custom":
            meeting.typing_speed = st.slider(
                "커스텀 타이핑 속도 (초/단어)",
                min_value=0.01,
                max_value=0.5,
                value=meeting.typing_speed,
                step=0.01,
                help="숫자가 낮을수록 빠르게 타이핑됩니다"
            )
        else:
            meeting.typing_speed = typing_options[selected_option]
        
        # 타이핑 속도 미리보기
        with st.expander("⚡ 타이핑 속도 미리보기", expanded=False):
            if st.button("🎬 테스트 해보기"):
                sample_text = "안녕하세요! 이것은 타이핑 속도 테스트입니다. 현재 설정된 속도로 텍스트가 표시됩니다."
                st.write("**샘플 텍스트:**")
                st.write_stream(stream_response(sample_text, meeting.typing_speed))
                st.caption(f"현재 설정: {meeting.typing_speed}초/단어")
        
        st.divider()
        
        # 파일 업로드
        st.header("📁 참고 자료 업로드")
        uploaded_files = st.file_uploader(
            "파일을 업로드하세요",
            type=['txt','md','pdf', 'docx', 'csv'],
            accept_multiple_files=True,
            help="페르소나들이 참고할 자료를 업로드하세요"
        )
        
        if uploaded_files:
            if st.button("📄 파일 처리"):
                with st.spinner("파일을 처리 중입니다..."):
                    combined_content = ""
                    for file in uploaded_files:
                        content = extract_text_from_file(file)
                        combined_content += f"\n--- {file.name} ---\n{content}\n"
                    
                    meeting.uploaded_files_content = combined_content
                    st.success(f"✅ {len(uploaded_files)}개 파일이 처리되었습니다!")
            
            # 파일이 처리된 경우 분석 결과 표시
            if meeting.uploaded_files_content:
                st.subheader("📖 파일 분석 결과")
                
                # 파일 분석 실행
                analysis = meeting.analyze_uploaded_files()
                
                # 분석 정보 표시
                col1, col2, col3 = st.columns(3)
                with col1:
                    st.metric("📄 총 길이", f"{analysis.get('total_length', 0):,}자")
                with col2:
                    st.metric("📝 단어 수", f"{analysis.get('word_count', 0):,}개")
                with col3:
                    st.metric("🔑 키워드", f"{len(analysis.get('keywords', [])):,}개")
                
                # 핵심 키워드 표시
                if analysis.get('keywords'):
                    st.write("**🔑 핵심 키워드:**")
                    keyword_display = ", ".join(analysis['keywords'][:15])
                    st.info(keyword_display)
                
                # 회의 주제와의 연관성 표시
                if meeting.meeting_topic:
                    topic_keywords = meeting.meeting_topic.replace(',', ' ').replace('.', ' ').split()
                    topic_keywords = [k.strip().lower() for k in topic_keywords if len(k.strip()) >= 2]
                    file_keywords = [k.lower() for k in analysis.get('keywords', [])]
                    
                    matching_keywords = [k for k in topic_keywords if k in file_keywords]
                    if matching_keywords:
                        st.success(f"✅ 회의 주제와 매칭되는 키워드: {', '.join(matching_keywords)}")
                    else:
                        st.warning("⚠️ 회의 주제와 직접적으로 매칭되는 키워드가 없습니다.")
                
                # 파일 내용 미리보기 (토글)
                with st.expander("📋 파일 내용 미리보기", expanded=False):
                    st.text_area(
                        "처리된 내용",
                        value=analysis.get('summary', meeting.uploaded_files_content[:500]),
                        height=150,
                        disabled=True,
                        key="file_preview"
                    )
                
                # RAG 활용 미리보기
                if meeting.meeting_topic:
                    with st.expander("🔍 AI가 활용할 관련 내용 미리보기", expanded=False):
                        relevant_content = meeting.get_relevant_file_content(topic_keywords)
                        if relevant_content:
                            st.text_area(
                                "회의 주제와 관련된 파일 내용",
                                value=relevant_content,
                                height=200,
                                disabled=True,
                                help="이 내용이 AI 응답 생성 시 우선적으로 참고됩니다"
                            )
                        else:
                            st.info("회의 주제와 관련된 특정 내용을 찾지 못했습니다. 전체 요약이 사용됩니다.")
        
        st.divider()
        
        # 회의 제어
        st.header("🎮 회의 제어")
        
        if not meeting.is_active:
            if st.button("🚀 회의 시작", type="primary"):
                if meeting.meeting_topic and len(meeting.personas) > 1:
                    meeting.is_active = True
                    meeting.start_time = datetime.now()
                    meeting.conversation_round = 0
                    meeting.current_speaker_index = 0
                    
                    # 사회자 인사말 추가
                    moderator = meeting.get_moderator()
                    if moderator:
                        opening_message = f"안녕하세요, 오늘 '{meeting.meeting_topic}'에 대해 논의하겠습니다. 모든 참가자들의 활발한 참여를 부탁드립니다."
                        meeting.add_message(moderator.id, opening_message)
                    
                    st.success("✅ 회의가 시작되었습니다!")
                    st.rerun()
                else:
                    st.error("⚠️ 회의 주제와 최소 2명의 페르소나가 필요합니다.")
        else:
            # 회의 진행 상태 표시
            if meeting.start_time:
                elapsed = datetime.now() - meeting.start_time
                remaining = meeting.meeting_duration * 60 - elapsed.seconds
                st.info(f"⏰ 경과: {elapsed.seconds//60}분 | 남은시간: {max(0, remaining//60)}분")
            
            col1, col2 = st.columns(2)
            with col1:
                if st.button("⏸️ 회의 중단"):
                    meeting.is_active = False
                    st.success("⏸️ 회의가 중단되었습니다.")
                    st.rerun()
            with col2:
                if st.button("🔄 회의 재시작"):
                    meeting.is_active = True
                    st.success("▶️ 회의가 재시작되었습니다.")
                    st.rerun()
            
            # 자동 모드 토글
            meeting.auto_mode = st.toggle("🤖 자동 진행 모드", value=meeting.auto_mode)
            if meeting.auto_mode:
                st.info("🔄 자동 모드가 활성화되었습니다.")
        
        # 회의 종료 조건
        if meeting.is_active:
            st.divider()
            st.header("📊 진행 상황")
            progress = min(meeting.conversation_round / meeting.max_rounds, 1.0)
            st.progress(progress, text=f"라운드 진행: {meeting.conversation_round}/{meeting.max_rounds}")
    
    # 메인 영역
    tab1, tab2, tab3, tab4 = st.tabs(["👥 페르소나 관리", "💬 실시간 회의", "📊 회의 현황", "📝 회의록"])
    
    with tab1:
        st.header("👥 페르소나 관리")
        
        # 프리셋 페르소나 추가
        st.subheader("🎯 프리셋 페르소나")
        preset_options = preset_personas()
        
        col1, col2 = st.columns([3, 1])
        with col1:
            selected_preset = st.selectbox(
                "프리셋 선택",
                options=range(len(preset_options)),
                format_func=lambda x: f"{preset_options[x]['name']} ({preset_options[x]['role']})",
                index=None,
                placeholder="프리셋을 선택하세요"
            )
        with col2:
            if selected_preset is not None and st.button("➕ 프리셋 추가"):
                preset = preset_options[selected_preset]
                new_persona = Persona(
                    id=str(uuid.uuid4()),
                    name=preset['name'],
                    role=preset['role'],
                    prompt="",  # 자동 생성됨
                    personality=preset['personality'],
                    expertise=preset['expertise'],
                    speaking_style=preset['speaking_style']
                )
                
                if meeting.add_persona(new_persona):
                    st.success(f"✅ {preset['name']} 페르소나가 추가되었습니다!")
                    st.rerun()
                else:
                    st.error("❌ 최대 10개의 페르소나만 추가할 수 있습니다.")
        
        st.divider()
        
        # 커스텀 페르소나 추가
        with st.expander("➕ 커스텀 페르소나 추가", expanded=False):
            with st.form("add_persona"):
                col1, col2 = st.columns(2)
                with col1:
                    name = st.text_input("이름", placeholder="예: 김전문")
                    role = st.text_input("역할", placeholder="예: 마케팅 담당자")
                    expertise = st.text_input("전문 분야", placeholder="예: 디지털 마케팅, SNS 전략")
                with col2:
                    personality = st.text_area("성격/특성", placeholder="예: 창의적이고 도전적인 성격")
                    speaking_style = st.text_input("말하는 스타일", placeholder="예: 열정적이고 구체적인 말투")
                
                prompt = st.text_area(
                    "커스텀 프롬프트 (선택사항)",
                    help="비워두면 자동으로 생성됩니다",
                    placeholder="이 페르소나의 특별한 행동 패턴이나 전문성을 정의하는 프롬프트를 입력하세요"
                )
                
                if st.form_submit_button("페르소나 추가", type="primary"):
                    if name and role:
                        new_persona = Persona(
                            id=str(uuid.uuid4()),
                            name=name,
                            role=role,
                            prompt=prompt,
                            personality=personality,
                            expertise=expertise,
                            speaking_style=speaking_style
                        )
                        
                        if meeting.add_persona(new_persona):
                            st.success(f"✅ {name} 페르소나가 추가되었습니다!")
                            st.rerun()
                        else:
                            st.error("❌ 최대 10개의 페르소나만 추가할 수 있습니다.")
                    else:
                        st.error("⚠️ 이름과 역할은 필수 항목입니다.")
        
        # 기존 페르소나 목록
        st.subheader("현재 페르소나 목록")
        for i, persona in enumerate(meeting.personas):
            icon = "🎯" if persona.is_moderator else "🎭"
            
            with st.expander(f"{icon} {persona.name} ({persona.role})"):
                col1, col2 = st.columns([3, 1])
                
                with col1:
                    st.write(f"**전문 분야:** {persona.expertise}")
                    st.write(f"**성격:** {persona.personality}")
                    st.write(f"**말하는 스타일:** {persona.speaking_style}")
                    
                    # 프롬프트 표시 (expander 대신 toggle 사용)
                    show_prompt = st.toggle(
                        "🤖 AI 프롬프트 보기", 
                        key=f"show_prompt_{persona.id}_{i}"  # 인덱스 추가로 고유성 보장
                    )
                    if show_prompt:
                        st.text_area(
                            "프롬프트",
                            value=persona.prompt,
                            height=100,
                            disabled=True,
                            key=f"prompt_view_{persona.id}_{i}"  # 인덱스 추가로 고유성 보장
                        )
                
                with col2:
                    if not persona.is_moderator:
                        if st.button("🗑️ 삭제", key=f"delete_{persona.id}"):
                            meeting.remove_persona(persona.id)
                            st.success(f"✅ {persona.name} 페르소나가 삭제되었습니다.")
                            st.rerun()
                    else:
                        st.info("🔒 사회자")
    
    with tab2:
        st.header("💬 실시간 회의")
        
        if not meeting.is_active:
            st.info("ℹ️ 회의를 시작하려면 사이드바에서 '회의 시작' 버튼을 클릭하세요.")
            
            # 회의 시작 전 미리보기
            if meeting.meeting_topic:
                st.subheader("📋 회의 정보")
                st.write(f"**주제:** {meeting.meeting_topic}")
                st.write(f"**예상 시간:** {meeting.meeting_duration}분")
                st.write(f"**참여자:** {len(meeting.personas)}명")
                st.write(f"**참여자 목록:** {', '.join([p.name for p in meeting.personas])}")
        else:
            # 회의 진행 상황
            col1, col2, col3, col4 = st.columns(4)
            with col1:
                elapsed_time = datetime.now() - meeting.start_time
                st.metric("⏰ 경과 시간", f"{elapsed_time.seconds // 60}분")
            with col2:
                st.metric("🔄 현재 라운드", f"{meeting.conversation_round + 1}/{meeting.max_rounds}")
            with col3:
                st.metric("💬 총 메시지", len(meeting.messages))
            with col4:
                next_speaker = meeting.get_next_speaker()
                st.metric("🎤 다음 발언자", next_speaker.name if next_speaker else "없음")
            
            # 사회자 개입
            st.subheader("🎯 사회자 개입")
            moderator = meeting.get_moderator()
            if moderator:
                with st.form("moderator_form"):
                    human_input = st.text_area(
                        f"{moderator.name}로서 발언",
                        help="사회자 역할로 회의 방향을 제시하거나 의견을 추가하세요",
                        placeholder="예: 지금까지의 의견을 정리해보겠습니다..."
                    )
                    
                    if st.form_submit_button("💬 발언하기", type="primary"):
                        if human_input:
                            meeting.add_message(moderator.id, human_input, is_human_input=True)
                            st.success("✅ 발언이 추가되었습니다!")
                            st.rerun()
            
            # 대화 진행 컨트롤
            st.subheader("🗣️ 대화 진행")
            
            col1, col2, col3 = st.columns(3)
            with col1:
                if st.button("➡️ 다음 발언", type="primary"):
                    with st.spinner("🤖 AI가 응답을 생성 중입니다..."):
                        success = run_conversation_round(meeting)
                        if success:
                            st.rerun()
                        else:
                            st.info("ℹ️ 회의가 종료되었거나 더 이상 진행할 수 없습니다.")
            
            with col2:
                if st.button("⏭️ 라운드 스킵"):
                    meeting.conversation_round += 1
                    st.info("⏭️ 라운드가 스킵되었습니다.")
                    st.rerun()
            
            with col3:
                if st.button("🔚 회의 종료"):
                    meeting.is_active = False
                    # 사회자 마무리 발언
                    if moderator:
                        closing_message = "오늘 회의를 마치겠습니다. 모든 분들의 활발한 참여에 감사드립니다."
                        meeting.add_message(moderator.id, closing_message)
                    st.success("✅ 회의가 종료되었습니다.")
                    st.rerun()
            
            # 맥락 미리보기 (새로 추가)
            with st.expander("🔍 다음 발언 맥락 미리보기", expanded=False):
                next_speaker = meeting.get_next_speaker()
                if next_speaker:
                    st.write(f"**다음 발언자:** {next_speaker.name} ({next_speaker.role})")
                    
                    # 맥락 미리보기
                    comprehensive_context = get_comprehensive_meeting_context(meeting)
                    st.text_area(
                        "AI가 참고할 전체 맥락",
                        value=comprehensive_context,
                        height=200,
                        disabled=True,
                        help="이 맥락이 AI에게 전달되어 라운드별 연속성을 유지합니다"
                    )
                    
                    # 토큰 길이 정보
                    context_length = len(comprehensive_context)
                    st.caption(f"📊 맥락 길이: {context_length:,}자 (약 {context_length//4:,} 토큰)")
                else:
                    st.info("발언 가능한 참가자가 없습니다.")
            
            # 자동 진행 모드 상태 표시만 (실행은 메인 함수 끝에서)
            if meeting.auto_mode:
                st.success(f"🤖 자동 진행 모드 활성화 - {meeting.speaking_speed}초마다 자동 발언")
                
                # 자동 진행 상태 표시 - 정확한 시간 계산
                col1, col2 = st.columns([3, 1])
                with col1:
                    if meeting.last_message_time:
                        time_since_last = (datetime.now() - meeting.last_message_time).total_seconds()
                        remaining_time = max(0, meeting.speaking_speed - time_since_last)
                        progress_value = min(1.0, (meeting.speaking_speed - remaining_time) / meeting.speaking_speed)
                        
                        if remaining_time <= 0:
                            st.success("⚡ 다음 발언 실행 중...")
                        else:
                            st.progress(
                                progress_value,
                                text=f"다음 발언까지 {remaining_time:.1f}초 남음"
                            )
                    else:
                        st.info("🚀 첫 발언 준비 중...")
                
                with col2:
                    if st.button("⏸️ 자동모드 중단"):
                        meeting.auto_mode = False
                        st.info("자동 모드가 중단되었습니다.")
                        st.rerun()
            
            # 대화 내용 표시 (항상 최신 상태로)
            st.subheader("💭 대화 내용")
            
            # 대화 컨테이너 (스크롤 가능)
            chat_container = st.container()
            with chat_container:
                if meeting.messages:
                    # 모든 메시지 표시 (최신 메시지만 타이핑 효과)
                    for i, message in enumerate(meeting.messages):
                        is_latest = (i == len(meeting.messages) - 1)  # 마지막 메시지인지 확인
                        display_message(message, is_latest=is_latest)
                    
                    # 최신 메시지 강조
                    st.info(f"💬 총 메시지: {len(meeting.messages)}개 | 마지막 발언: {meeting.messages[-1].timestamp.strftime('%H:%M:%S')}")
                else:
                    st.info("💭 아직 대화가 시작되지 않았습니다.")
                
                # 자동 스크롤을 위한 앵커
                st.write("")
    
    with tab3:
        st.header("📊 회의 현황")
        
        if meeting.messages:
            # 회의 개요
            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric("💬 총 발언 수", len(meeting.messages))
            with col2:
                human_messages = sum(1 for msg in meeting.messages if msg.is_human_input)
                st.metric("👤 인간 개입", human_messages)
            with col3:
                if meeting.start_time:
                    duration = datetime.now() - meeting.start_time
                    st.metric("⏱️ 회의 시간", f"{duration.seconds//60}분 {duration.seconds%60}초")
            
            # 추가 시스템 설정 정보
            col4, col5, col6, col7 = st.columns(4)
            with col4:
                st.metric("🕐 발언 간격", f"{meeting.speaking_speed}초")
            with col5:
                st.metric("⌨️ 타이핑 속도", f"{meeting.typing_speed}초/단어")
            with col6:
                saved_count = len(get_saved_meeting_records())
                st.metric("💾 저장된 회의록", f"{saved_count}개")
            with col7:
                current_ai_model = st.session_state.get('selected_ai_model', 'gpt-4o-mini')
                model_display = current_ai_model.split('-')[0].upper()  # claude 또는 GPT
                st.metric("🧠 AI 모델", model_display)
            
            # 발언 통계
            speaker_stats = {}
            for message in meeting.messages:
                if message.persona_name in speaker_stats:
                    speaker_stats[message.persona_name] += 1
                else:
                    speaker_stats[message.persona_name] = 1
            
            # 발언 횟수 차트
            if speaker_stats:
                st.subheader("👤 발언자별 통계")
                df_stats = pd.DataFrame(list(speaker_stats.items()), columns=['발언자', '발언 횟수'])
                df_stats = df_stats.sort_values('발언 횟수', ascending=True)
                st.bar_chart(df_stats.set_index('발언자'))
                
                # 발언 분포 파이 차트
                try:
                    import plotly.express as px
                    fig = px.pie(df_stats, values='발언 횟수', names='발언자', title='발언 분포')
                    st.plotly_chart(fig, use_container_width=True)
                except ImportError:
                    st.info("📊 Plotly가 설치되지 않아 파이 차트를 표시할 수 없습니다.")
            
            # 시간대별 활동
            st.subheader("📈 시간대별 활동")
            if len(meeting.messages) > 1:
                time_data = []
                for i, message in enumerate(meeting.messages):
                    time_data.append({
                        '순서': i + 1,
                        '시간': message.timestamp.strftime('%H:%M:%S'),
                        '발언자': message.persona_name,
                        '내용 길이': len(message.content)
                    })
                
                df_time = pd.DataFrame(time_data)
                st.line_chart(df_time.set_index('순서')['내용 길이'])
            
            # 라운드별 요약 현황 (새로 추가)
            st.subheader("🔄 라운드별 맥락 유지 현황")
            if meeting.conversation_round > 0:
                for round_num in range(1, meeting.conversation_round + 1):
                    with st.expander(f"📋 라운드 {round_num} 요약", expanded=False):
                        summary = meeting.generate_round_summary(round_num)
                        if summary:
                            st.text(summary)
                        else:
                            st.info("요약 생성 중...")
            else:
                st.info("아직 완료된 라운드가 없습니다.")
            
            # 핵심 인사이트 (새로 추가)
            key_insights = meeting.extract_key_insights()
            if key_insights:
                st.subheader("💡 핵심 인사이트")
                for insight in key_insights:
                    st.write(f"• {insight}")
            
            # 참고 자료 활용 현황 (새로 추가)
            if meeting.uploaded_files_content:
                st.subheader("📊 참고 자료 활용 현황")
                analysis = meeting.analyze_uploaded_files()
                
                col1, col2 = st.columns(2)
                with col1:
                    st.metric("📄 파일 크기", f"{analysis.get('total_length', 0):,}자")
                    st.metric("🔑 추출된 키워드", f"{len(analysis.get('keywords', []))}")
                
                with col2:
                    # 회의 주제와 키워드 매칭률 계산
                    if meeting.meeting_topic and analysis.get('keywords'):
                        topic_keywords = meeting.meeting_topic.replace(',', ' ').replace('.', ' ').split()
                        topic_keywords = [k.strip().lower() for k in topic_keywords if len(k.strip()) >= 2]
                        file_keywords = [k.lower() for k in analysis.get('keywords', [])]
                        
                        matching_keywords = [k for k in topic_keywords if k in file_keywords]
                        match_rate = len(matching_keywords) / len(topic_keywords) * 100 if topic_keywords else 0
                        
                        st.metric("🎯 주제 연관도", f"{match_rate:.1f}%")
                        st.metric("✅ 매칭 키워드", f"{len(matching_keywords)}개")
                
                # 파일 활용 품질 지표
                with st.expander("📈 파일 활용 분석", expanded=False):
                    if analysis.get('keywords'):
                        st.write("**🔑 상위 키워드:**")
                        st.write(", ".join(analysis['keywords'][:10]))
                    
                    if analysis.get('sections'):
                        st.write(f"**📁 섹션 구분:** {len(analysis['sections'])}개")
                        for i, section in enumerate(analysis['sections'][:3]):
                            st.write(f"  {i+1}. {section['title']}")
                    
                    # RAG 품질 평가
                    if meeting.meeting_topic:
                        relevant_content = meeting.get_relevant_file_content(topic_keywords)
                        if "관련 참고 자료" in relevant_content:
                            st.success("✅ RAG 시스템이 관련 내용을 성공적으로 추출했습니다")
                        else:
                            st.info("ℹ️ 전체 요약을 사용하여 참고 자료를 활용합니다")
            
            # 저장된 회의록 현황 (새로 추가)
            st.subheader("💾 저장된 회의록 현황")
            saved_records = get_saved_meeting_records()
            
            if saved_records:
                # 최근 5개 회의록만 표시
                recent_saved = saved_records[:5]
                
                for record in recent_saved:
                    with st.container():
                        col1, col2, col3 = st.columns([3, 2, 1])
                        with col1:
                            st.write(f"📋 **{record['title']}**")
                        with col2:
                            st.caption(f"📅 {record['date'].strftime('%Y-%m-%d %H:%M')}")
                        with col3:
                            if st.button("📖", key=f"quick_view_{record['meeting_id']}", help="빠른 보기"):
                                st.session_state.selected_meeting_id = record['meeting_id']
                
                if len(saved_records) > 5:
                    st.caption(f"... 외 {len(saved_records) - 5}개 더 (회의록 탭에서 전체 확인)")
            else:
                st.info("저장된 회의록이 없습니다.")
            
            # 최근 활동
            st.subheader("🕐 최근 활동")
            recent_messages = meeting.messages[-10:] if len(meeting.messages) > 10 else meeting.messages
            for message in reversed(recent_messages):
                icon = "🎯" if message.is_moderator else "🎭"
                if message.is_human_input:
                    icon = "👤"
                
                st.write(
                    f"{icon} **{message.timestamp.strftime('%H:%M:%S')}** - "
                    f"{message.persona_name}: {message.content[:100]}..."
                )
        else:
            st.info("ℹ️ 아직 회의 메시지가 없습니다.")
    
    with tab4:
        st.header("📝 회의록")
        
        # 서브탭 생성
        subtab1, subtab2, subtab3 = st.tabs(["📝 현재 회의록", "💾 회의록 저장", "📚 저장된 회의록"])
        
        with subtab1:
            st.subheader("📝 현재 회의 내용")
            
            if meeting.messages:
                # 회의록 생성
                meeting_log = generate_meeting_log(meeting)
                
                # 다운로드 버튼
                col1, col2, col3 = st.columns([1, 1, 1])
                with col1:
                    st.download_button(
                        label="📥 Markdown 다운로드",
                        data=meeting_log,
                        file_name=f"meeting_log_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md",
                        mime="text/markdown"
                    )
                with col2:
                    # JSON 형태로도 다운로드 가능
                    json_data = {
                        "meeting_info": {
                            "topic": meeting.meeting_topic,
                            "start_time": meeting.start_time.isoformat() if meeting.start_time else None,
                            "duration": meeting.meeting_duration,
                            "participants": [{"name": p.name, "role": p.role} for p in meeting.personas]
                        },
                        "messages": [
                            {
                                "timestamp": msg.timestamp.isoformat(),
                                "speaker": msg.persona_name,
                                "content": msg.content,
                                "is_human_input": msg.is_human_input
                            } for msg in meeting.messages
                        ]
                    }
                    
                    st.download_button(
                        label="📊 JSON 다운로드",
                        data=json.dumps(json_data, ensure_ascii=False, indent=2),
                        file_name=f"meeting_data_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json",
                        mime="application/json"
                    )
                
                # 회의록 미리보기
                st.subheader("👀 회의록 미리보기")
                st.markdown(meeting_log)
            else:
                st.info("ℹ️ 회의록이 비어있습니다.")
        
        with subtab2:
            st.subheader("💾 회의록 데이터베이스 저장")
            
            if meeting.messages:
                # 회의록 생성
                meeting_log = generate_meeting_log(meeting)
                
                # AI 요약 생성 버튼
                col1, col2 = st.columns([2, 1])
                with col1:
                    st.write("**📋 AI 회의록 요약 생성**")
                    st.caption("AI가 회의 내용을 분석하여 구조화된 요약을 생성합니다.")
                
                with col2:
                    if st.button("🤖 AI 요약 생성", type="secondary"):
                        with st.spinner("AI가 회의록을 요약하고 있습니다..."):
                            selected_model = st.session_state.get('selected_ai_model', 'gpt-4o-mini')
                            summary = generate_meeting_summary(meeting_log, selected_model)
                            st.session_state.meeting_summary = summary
                
                # 생성된 요약 표시
                if 'meeting_summary' in st.session_state:
                    st.subheader("📋 AI 생성 요약")
                    st.markdown(st.session_state.meeting_summary)
                    
                    # 저장 버튼
                    col1, col2 = st.columns([1, 1])
                    with col1:
                        if st.button("💾 회의록 저장", type="primary"):
                            if save_meeting_record(meeting, meeting_log, st.session_state.meeting_summary):
                                st.success("✅ 회의록이 성공적으로 저장되었습니다!")
                                # 요약 세션 상태 클리어
                                if 'meeting_summary' in st.session_state:
                                    del st.session_state.meeting_summary
                                st.rerun()
                            else:
                                st.error("❌ 회의록 저장에 실패했습니다.")
                    
                    with col2:
                        if st.button("🔄 요약 재생성"):
                            if 'meeting_summary' in st.session_state:
                                del st.session_state.meeting_summary
                            st.rerun()
                else:
                    st.info("💡 먼저 'AI 요약 생성' 버튼을 클릭하여 회의록 요약을 생성해주세요.")
                
                # 저장 정보 안내
                st.markdown("""
                ---
                ### 📊 저장될 정보
                - **회의 주제**: {topic}
                - **회의 일시**: {date}
                - **참가자**: {participants}
                - **전체 대화록**: 모든 발언 내용
                - **AI 요약**: 구조화된 회의 요약
                """.format(
                    topic=meeting.meeting_topic,
                    date=meeting.start_time.strftime('%Y-%m-%d %H:%M:%S') if meeting.start_time else "미정",
                    participants=", ".join([p.name for p in meeting.personas])
                ))
            else:
                st.info("ℹ️ 저장할 회의 내용이 없습니다.")
        
        with subtab3:
            st.subheader("📚 저장된 회의록 관리")
            
            # 저장된 회의록 목록 조회
            saved_records = get_saved_meeting_records()
            
            if saved_records:
                # 검색 기능
                search_term = st.text_input("🔍 회의록 검색", placeholder="회의 주제나 참가자명으로 검색...")
                
                # 검색 필터링
                if search_term:
                    filtered_records = [
                        record for record in saved_records 
                        if search_term.lower() in record['title'].lower() or 
                           search_term.lower() in record['participants'].lower()
                    ]
                else:
                    filtered_records = saved_records
                
                st.write(f"**📊 총 {len(filtered_records)}개의 회의록이 있습니다.**")
                
                # 회의록 목록 표시
                for record in filtered_records:
                    with st.expander(f"📅 {record['date'].strftime('%Y-%m-%d %H:%M')} - {record['title']}", expanded=False):
                        col1, col2, col3 = st.columns([2, 1, 1])
                        
                        with col1:
                            st.write(f"**참가자**: {record['participants']}")
                            st.write(f"**저장일시**: {record['created_at'].strftime('%Y-%m-%d %H:%M:%S')}")
                        
                        with col2:
                            if st.button("📖 상세보기", key=f"view_{record['meeting_id']}"):
                                st.session_state.selected_meeting_id = record['meeting_id']
                        
                        with col3:
                            if st.button("🗑️ 삭제", key=f"delete_{record['meeting_id']}", type="secondary"):
                                if delete_meeting_record(record['meeting_id']):
                                    st.success("✅ 회의록이 삭제되었습니다.")
                                    st.rerun()
                                else:
                                    st.error("❌ 삭제에 실패했습니다.")
                
                # 선택된 회의록 상세 보기
                if 'selected_meeting_id' in st.session_state:
                    st.markdown("---")
                    st.subheader("📖 회의록 상세 내용")
                    
                    detail = get_meeting_record_detail(st.session_state.selected_meeting_id)
                    if detail:
                        # 기본 정보
                        col1, col2 = st.columns(2)
                        with col1:
                            st.write(f"**📋 회의 주제**: {detail['title']}")
                            st.write(f"**📅 회의 일시**: {detail['date'].strftime('%Y-%m-%d %H:%M:%S')}")
                        with col2:
                            st.write(f"**👥 참가자**: {detail['participants']}")
                            st.write(f"**💾 저장일시**: {detail['created_at'].strftime('%Y-%m-%d %H:%M:%S')}")
                        
                        # 탭으로 구분된 내용
                        detail_tab1, detail_tab2 = st.tabs(["📋 AI 요약", "📝 전체 대화록"])
                        
                        with detail_tab1:
                            if detail['summary']:
                                st.markdown(detail['summary'])
                            else:
                                st.info("요약이 없습니다.")
                        
                        with detail_tab2:
                            if detail['full_text']:
                                st.markdown(detail['full_text'])
                            else:
                                st.info("대화록이 없습니다.")
                        
                        # 다운로드 버튼
                        col1, col2, col3 = st.columns(3)
                        with col1:
                            st.download_button(
                                label="📥 요약 다운로드",
                                data=detail['summary'] or "요약 없음",
                                file_name=f"meeting_summary_{detail['meeting_id']}.md",
                                mime="text/markdown"
                            )
                        with col2:
                            st.download_button(
                                label="📥 전체 대화록 다운로드",
                                data=detail['full_text'] or "대화록 없음",
                                file_name=f"meeting_full_{detail['meeting_id']}.md",
                                mime="text/markdown"
                            )
                        with col3:
                            if st.button("❌ 상세보기 닫기"):
                                if 'selected_meeting_id' in st.session_state:
                                    del st.session_state.selected_meeting_id
                                st.rerun()
                    else:
                        st.error("회의록을 찾을 수 없습니다.")
            else:
                st.info("📝 저장된 회의록이 없습니다. 회의를 진행한 후 '회의록 저장' 탭에서 저장해보세요.")

    # 🚀 자동 모드 실행 로직 (메인 함수 끝에서 실제 대화 실행)
    if meeting.auto_mode and meeting.is_active and meeting.should_continue():
        if meeting.is_time_to_speak():
            # 실제로 대화 실행
            success = run_conversation_round(meeting)
            if success:
                # 새로운 메시지가 추가되었으므로 즉시 새로고침
                st.rerun()
            else:
                # 회의 자동 종료
                meeting.is_active = False
                meeting.auto_mode = False
                moderator = meeting.get_moderator()
                if moderator:
                    closing_message = "자동 모드로 진행된 회의를 마치겠습니다. 모든 분들의 의견에 감사드립니다."
                    meeting.add_message(moderator.id, closing_message)
                st.success("✅ 자동 모드 회의가 완료되었습니다.")
                st.rerun()
        else:
            # 시간이 안 되었으면 1초 후 다시 체크
            time.sleep(1)
            st.rerun()

def generate_meeting_log(meeting: VirtualMeeting) -> str:
    """회의록 생성"""
    log = f"""# 📋 회의록

## 🎯 회의 정보
- **주제**: {meeting.meeting_topic}
- **시작 시간**: {meeting.start_time.strftime('%Y-%m-%d %H:%M:%S') if meeting.start_time else 'N/A'}
- **예정 시간**: {meeting.meeting_duration}분
- **총 라운드**: {meeting.conversation_round}
- **참여자 수**: {len(meeting.personas)}명

## 👥 참여자 목록
"""
    for persona in meeting.personas:
        icon = "🎯" if persona.is_moderator else "🎭"
        log += f"- {icon} **{persona.name}** ({persona.role})\n"
    
    log += f"\n## 💬 대화 내용 ({len(meeting.messages)}개 메시지)\n\n"
    
    current_round = 0
    for i, message in enumerate(meeting.messages):
        # 라운드 구분
        if i > 0 and not message.is_human_input and not message.is_moderator:
            speaker_index = [j for j, p in enumerate(meeting.get_non_moderator_personas()) 
                           if p.id == message.persona_id]
            if speaker_index and speaker_index[0] == 0:
                current_round += 1
                log += f"\n### 🔄 라운드 {current_round}\n\n"
        
        # 메시지 추가
        icon = "🎯" if message.is_moderator else "🎭"
        if message.is_human_input:
            icon = "👤"
        
        log += f"**{message.timestamp.strftime('%H:%M:%S')}** {icon} **{message.persona_name}**\n"
        log += f"> {message.content}\n\n"
    
    log += f"\n---\n*회의록 생성 시간: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*"
    
    return log

if __name__ == "__main__":
    main() 